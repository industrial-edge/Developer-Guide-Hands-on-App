"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installAlarmMonitoring = exports.uninstallAlarmMonitoring = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_service_filter_1 = require("node-opcua-service-filter");
const node_opcua_service_read_1 = require("node-opcua-service-read");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_debug_1 = require("node-opcua-debug");
const client_alarm_1 = require("./client_alarm");
const client_alarm_list_1 = require("./client_alarm_list");
const client_alarm_tools_extractConditionFields_1 = require("./client_alarm_tools_extractConditionFields");
const client_tools_1 = require("./client_tools");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("A&E");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("A&E");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("A&E");
function r(_key, o) {
    if (o && o.dataType === "Null") {
        return undefined;
    }
    return o;
}
// ------------------------------------------------------------------------------------------------------------------------------
function uninstallAlarmMonitoring(session) {
    return __awaiter(this, void 0, void 0, function* () {
        const _sessionPriv = session;
        if (!_sessionPriv.$clientAlarmList) {
            return;
        }
        const mi = _sessionPriv.$monitoredItemForAlarmList;
        mi.removeAllListeners();
        _sessionPriv.$monitoredItemForAlarmList = null;
        yield _sessionPriv.$subscriptionforAlarmList.terminate();
        _sessionPriv.$clientAlarmList = null;
        return;
    });
}
exports.uninstallAlarmMonitoring = uninstallAlarmMonitoring;
// Release 1.04 8 OPC Unified Architecture, Part 9
// 4.5 Condition state synchronization
//
// A Client that wishes to display the current status of Alarms and Conditions (known as a
// “current Alarm display”) would use the following logic to process Refresh Event Notifications.
// The Client flags all Retained Conditions as suspect on reception of the Event of the
// RefreshStartEventType. The Client adds any new Events that are received during the Refresh
// without flagging them as suspect. The Client also removes the suspect flag from any Retained
// Conditions that are returned as part of the Refresh. When the Client receives a
// RefreshEndEvent, the Client removes any remaining suspect Events, since they no longer
// apply.
// ------------------------------------------------------------------------------------------------------------------------------
function installAlarmMonitoring(session) {
    return __awaiter(this, void 0, void 0, function* () {
        const _sessionPriv = session;
        // create
        if (_sessionPriv.$clientAlarmList) {
            return _sessionPriv.$clientAlarmList;
        }
        const clientAlarmList = new client_alarm_list_1.ClientAlarmList();
        _sessionPriv.$clientAlarmList = clientAlarmList;
        const request = {
            maxNotificationsPerPublish: 100,
            priority: 6,
            publishingEnabled: true,
            requestedLifetimeCount: 10000,
            requestedMaxKeepAliveCount: 10,
            requestedPublishingInterval: 500
        };
        const subscription = yield session.createSubscription2(request);
        _sessionPriv.$subscriptionforAlarmList = subscription;
        const itemToMonitor = {
            attributeId: node_opcua_data_model_1.AttributeIds.EventNotifier,
            nodeId: (0, node_opcua_nodeid_1.resolveNodeId)("Server") // i=2253
        };
        const fields = yield (0, client_alarm_tools_extractConditionFields_1.extractConditionFields)(session, "AlarmConditionType");
        const AcknowledgeableConditionType = (0, node_opcua_nodeid_1.resolveNodeId)("AcknowledgeableConditionType");
        const eventFilter = (0, node_opcua_service_filter_1.constructEventFilter)(fields, (0, node_opcua_service_filter_1.ofType)(AcknowledgeableConditionType));
        const monitoringParameters = {
            discardOldest: false,
            filter: eventFilter,
            queueSize: 1000,
            samplingInterval: 0
        };
        // now create a event monitored Item
        const eventMonitoringItem = yield subscription.monitor(itemToMonitor, monitoringParameters, node_opcua_service_read_1.TimestampsToReturn.Both);
        const queueEvent = [];
        function flushQueue() {
            const q = [...queueEvent];
            queueEvent.length = 0;
            for (const pojo of q) {
                clientAlarmList.update(pojo);
            }
        }
        let inInit = true;
        eventMonitoringItem.on("changed", (eventFields) => {
            var _a, _b;
            const pojo = (0, client_alarm_1.fieldsToJson)(fields, eventFields);
            const { eventType, eventId, conditionId, conditionName } = pojo;
            debugLog("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ---- ALARM RECEIVED " +
                eventType.value.toString() +
                " " +
                ((_a = eventId.value) === null || _a === void 0 ? void 0 : _a.toString("hex")));
            try {
                if (!conditionId || !conditionId.value || conditionId.dataType === node_opcua_variant_1.DataType.Null) {
                    // not a acknowledgeable condition
                    warningLog(" not acknowledgeable condition ---- " + eventType.value.toString() + " ", conditionId, conditionName === null || conditionName === void 0 ? void 0 : conditionName.value, " " + ((_b = eventId.value) === null || _b === void 0 ? void 0 : _b.toString("hex")));
                    return;
                }
                queueEvent.push(pojo);
                if (queueEvent.length === 1 && !inInit) {
                    setTimeout(() => flushQueue(), 10);
                }
            }
            catch (err) {
                warningLog(JSON.stringify(pojo, r, " "));
                warningLog("Error !!", err);
            }
            // Release 1.04 8 OPC Unified Architecture, Part 9
            // 4.5 Condition state synchronization
            // RefreshRequiredEventType
            // Under some circumstances a Server may not be capable of ensuring the Client is fully
            //  in sync with the current state of Condition instances. For example, if the underlying
            // system represented by the Server is reset or communications are lost for some period
            // of time the Server may need to resynchronize itself with the underlying system. In
            // these cases, the Server shall send an Event of the RefreshRequiredEventType to
            // advise the Client that a Refresh may be necessary. A Client receiving this special
            // Event should initiate a ConditionRefresh as noted in this clause.
            // TODO
        });
        try {
            yield (0, client_tools_1.callConditionRefresh)(subscription);
        }
        catch (err) {
            if (err.message.match(/BadNothingToDo/)) {
                /** fine! nothing to do */
            }
            else {
                warningLog("Server may not implement condition refresh", err.message);
            }
        }
        _sessionPriv.$monitoredItemForAlarmList = eventMonitoringItem;
        setTimeout(() => flushQueue(), 10);
        inInit = false;
        // also request updates
        return clientAlarmList;
    });
}
exports.installAlarmMonitoring = installAlarmMonitoring;
//# sourceMappingURL=client_alarm_tools.js.map