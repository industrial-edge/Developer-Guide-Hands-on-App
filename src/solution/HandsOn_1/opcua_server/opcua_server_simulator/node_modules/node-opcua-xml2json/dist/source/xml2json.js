"use strict";
/**
 * @module node-opcua-xml2json
 * node -> see if https://github.com/isaacs/sax-js could be used instead
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xml2Json = exports.ReaderState = exports.ReaderStateBase = void 0;
// tslint:disable:max-classes-per-file
// tslint:disable:no-var-requires
// tslint:disable:unified-signatures
const node_opcua_assert_1 = require("node-opcua-assert");
const LtxParser = require("ltx/lib/parsers/ltx.js");
/**
 * @static
 * @private
 * @method _coerceParser
 * @param parser {map<ReaderState|options>}
 * @return {map}
 */
function _coerceParser(parser) {
    for (const name of Object.keys(parser)) {
        if (parser[name] && !(parser[name] instanceof ReaderState)) {
            // this is to prevent recursion
            const tmp = parser[name];
            delete parser[name];
            parser[name] = new ReaderState(tmp);
        }
    }
    return parser;
}
class ReaderStateBase {
}
exports.ReaderStateBase = ReaderStateBase;
/**
 * @class ReaderState
 * @private
 * @param options
 * @param [options.parser=null]  {map<ReaderState|options}}
 * @param [options.init|null]
 * @param [options.finish]
 * @param [options.startElement]
 * @param [options.endElement]
 */
class ReaderState extends ReaderStateBase {
    constructor(options) {
        super();
        this.chunks = [];
        this.text = "";
        this.name = "";
        this.level = -1;
        this.currentLevel = -1;
        // ensure options object has only expected properties
        options.parser = options.parser || {};
        if (!(options instanceof ReaderStateBase)) {
            this._init = options.init;
            this._finish = options.finish;
            this._startElement = options.startElement;
            this._endElement = options.endElement;
        }
        this.parser = _coerceParser(options.parser);
    }
    /**
     * @method _on_init
     * @param elementName  - the name of the element
     * @param attrs
     * @param parent
     * @param level
     * @param engine
     * @protected
     */
    _on_init(elementName, attrs, parent, level, engine) {
        this.name = elementName;
        this.parent = parent;
        this.engine = engine;
        this.data = {};
        this.level = level;
        this.currentLevel = this.level;
        this.attrs = attrs;
        (0, node_opcua_assert_1.assert)(this.attrs);
        if (this._init) {
            this._init(elementName, attrs, parent, engine);
        }
    }
    _on_finish() {
        if (this._finish) {
            this._finish();
        }
    }
    /**
     * @param level
     * @param elementName   - the name of the element
     * @param attrs
     * @protected
     */
    _on_startElement(level, elementName, attrs) {
        this.currentLevel = level;
        // console.log("wxxxx _on_startElement#" + this.name, elementName, this.currentLevel);
        this.chunks = [];
        this.text = "";
        if (this._startElement) {
            this._startElement(elementName, attrs);
        }
        if (this.engine && Object.prototype.hasOwnProperty.call(this.parser, elementName)) {
            // console.log("promoting ", elementName, this.level);
            this.engine._promote(this.parser[elementName], level, elementName, attrs);
        }
    }
    _on_endElement2(level, elementName) {
        if (this._endElement) {
            this._endElement(elementName);
        }
    }
    /**
     * @method _on_endElement
     * @protected
     */
    _on_endElement(level, elementName) {
        // console.log("wxxxx _on_endElement#" + this.name, elementName, level, this.currentLevel);
        (0, node_opcua_assert_1.assert)(this.attrs);
        this.chunks = this.chunks || [];
        if (this.level > level) {
            // we end a child element of this node
            this._on_endElement2(level, elementName);
        }
        else if (this.level === level) {
            // we received the end event of this node
            // we need to finish
            this.text = this.chunks.join("");
            this.chunks = [];
            // this is the end
            this._on_finish();
            if (this.parent &&
                this.parent.parser &&
                Object.prototype.hasOwnProperty.call(this.parent.parser, elementName)) {
                // console.log("xxx    demoting#" + this.name, elementName, this.level);
                this.engine._demote(this, level, elementName);
            }
        }
    }
    /**
     * @method _on_text
     * @param text {String} the text found inside the element
     * @protected
     */
    _on_text(text) {
        this.chunks = this.chunks || [];
        text = text.trim();
        if (text.length === 0) {
            return;
        }
        this.chunks.push(text);
    }
}
exports.ReaderState = ReaderState;
const regexp = /(([^:]+):)?(.*)/;
function resolve_namespace(name) {
    const m = name.match(regexp);
    if (!m) {
        throw new Error("Invalid match");
    }
    return {
        ns: m[2],
        tag: m[3]
    };
}
/**
 * @class Xml2Json
 * @param options - the state machine as  a ReaderState node.
 * @param [options.parser=null]  {ReaderState}
 * @param [options.init|null]
 * @param [options.finish]
 * @param [options.startElement]
 * @param [options.endElement]
 * @constructor
 *
 * @example
 *  var parser = new Xml2Json({
 *       parser: {
 *           'person': {
 *               init: function(name,attrs) {
 *                   this.parent.root.obj = {};
 *                   this.obj =  this.parent.root.obj;
 *                   this.obj['name'] = attrs['name'];
 *               },
 *               parser: {
 *                   'address': {
 *                       finish: function(){
 *                           this.parent.obj['address'] = this.text;
 *                       }
 *                   }
 *               }
 *           }
 *       }
 *   });
 *
 * var xml_string =  "<employees>" +
 * "  <person name='John'>" +
 * "     <address>Paris</address>" +
 * "   </person>" +
 * "</employees>";
 *
 * parser.parseString(xml_string, function() {
 *       parser.obj.should.eql({name: 'John',address: 'Paris'});
 *       done();
 *   });
 */
class Xml2Json {
    constructor(options) {
        this.currentLevel = 0;
        this.state_stack = [];
        this.current_state = null;
        const state = options instanceof ReaderStateBase ? options : new ReaderState(options);
        state.root = this;
        this.state_stack = [];
        this.current_state = null;
        this._promote(state, 0);
    }
    parseStringSync(xml_text) {
        let retValue = {};
        const parser = this._prepareParser((err, r) => retValue = r);
        parser.write(xml_text);
        parser.end();
        return retValue;
    }
    parseString(xml_text, callback) {
        const parser = this._prepareParser(callback);
        parser.write(xml_text);
        parser.end();
    }
    /**
     * @param new_state
     * @param name
     * @param attr
     * @private
     * @internal
     */
    _promote(new_state, level, name, attr) {
        attr = attr || {};
        this.state_stack.push({
            backup: {},
            state: this.current_state
        });
        const parent = this.current_state;
        this.current_state = new_state;
        this.current_state._on_init(name || "???", attr, parent, level, this);
    }
    /**
     *
     * @private
     * @internal
     */
    _demote(cur_state, level, elementName) {
        ///  assert(this.current_state === cur_state);
        const { state, backup } = this.state_stack.pop();
        this.current_state = state;
        if (this.current_state) {
            this.current_state._on_endElement2(level, elementName);
        }
    }
    _prepareParser(callback) {
        (0, node_opcua_assert_1.assert)(typeof callback === 'function');
        const parser = new LtxParser();
        this.currentLevel = 0;
        parser.on("startElement", (name, attrs) => {
            const tag_ns = resolve_namespace(name);
            this.currentLevel += 1;
            if (this.current_state) {
                this.current_state._on_startElement(this.currentLevel, tag_ns.tag, attrs);
            }
        });
        parser.on("endElement", (name) => {
            const tag_ns = resolve_namespace(name);
            if (this.current_state) {
                this.current_state._on_endElement(this.currentLevel, tag_ns.tag);
            }
            this.currentLevel -= 1;
            if (this.currentLevel === 0) {
                parser.emit("close");
            }
        });
        parser.on("text", (text) => {
            text = text.trim();
            if (text.length === 0) {
                return;
            }
            if (this.current_state) {
                this.current_state._on_text(text);
            }
        });
        parser.once("close", () => {
            if (callback) {
                callback(null, this.current_state._pojo);
            }
        });
        return parser;
    }
}
exports.Xml2Json = Xml2Json;
// tslint:disable:no-var-requires
const thenify = require("thenify");
const opts = { multiArgs: false };
Xml2Json.prototype.parseString = thenify.withCallback(Xml2Json.prototype.parseString, opts);
//# sourceMappingURL=xml2json.js.map