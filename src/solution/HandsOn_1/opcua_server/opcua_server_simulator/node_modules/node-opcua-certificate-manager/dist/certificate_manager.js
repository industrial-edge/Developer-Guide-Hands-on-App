"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultCertificateManager = exports.OPCUACertificateManager = void 0;
/**
 * @module node-opcua-certificate-manager
 */
// tslint:disable:no-empty
const fs = require("fs");
const path = require("path");
const mkdirp = require("mkdirp");
const env_paths_1 = require("env-paths");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const node_opcua_pki_1 = require("node-opcua-pki");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_object_registry_1 = require("node-opcua-object-registry");
const paths = (0, env_paths_1.default)("node-opcua-default");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
class OPCUACertificateManager extends node_opcua_pki_1.CertificateManager {
    /* */
    constructor(options) {
        options = options || {};
        const location = options.rootFolder || paths.config;
        if (!fs.existsSync(location)) {
            mkdirp.sync(location);
        }
        const _options = {
            keySize: options.keySize || 2048,
            location
        };
        super(_options);
        this.referenceCounter = 0;
        this.automaticallyAcceptUnknownCertificate = !!options.automaticallyAcceptUnknownCertificate;
    }
    initialize(...args) {
        const callback = args[0];
        (0, node_opcua_assert_1.assert)(callback && typeof callback === 'function');
        return super.initialize(callback);
    }
    dispose() {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.referenceCounter === 0) {
                yield _super.dispose.call(this);
            }
            else {
                this.referenceCounter--;
            }
        });
    }
    checkCertificate(certificateChain, callback) {
        // istanbul ignore next
        if (!callback || typeof callback !== "function") {
            throw new Error("Internal error");
        }
        this.verifyCertificate(certificateChain, (err1, status) => {
            // istanbul ignore next
            if (err1) {
                return callback(err1);
            }
            const statusCode = node_opcua_status_code_1.StatusCodes[status];
            debugLog("checkCertificate => StatusCode = ", statusCode.toString());
            if (statusCode === node_opcua_status_code_1.StatusCodes.BadCertificateUntrusted) {
                const thumbprint = (0, node_opcua_crypto_1.makeSHA1Thumbprint)(certificateChain).toString("hex");
                if (this.automaticallyAcceptUnknownCertificate) {
                    debugLog("automaticallyAcceptUnknownCertificate = true");
                    debugLog("certificate with thumbprint " + thumbprint + " is now trusted");
                    return this.trustCertificate(certificateChain, () => callback(null, node_opcua_status_code_1.StatusCodes.Good));
                }
                else {
                    debugLog("automaticallyAcceptUnknownCertificate = false");
                    debugLog("certificate with thumbprint " + thumbprint + " is now rejected");
                    return this.rejectCertificate(certificateChain, () => callback(null, node_opcua_status_code_1.StatusCodes.BadCertificateUntrusted));
                }
            }
            callback(null, statusCode);
        });
    }
    getTrustStatus(certificate, callback) {
        this.isCertificateTrusted(certificate, (err, trustedStatus) => {
            callback(err, err ? undefined : node_opcua_status_code_1.StatusCodes[trustedStatus]);
        });
    }
}
exports.OPCUACertificateManager = OPCUACertificateManager;
OPCUACertificateManager.defaultCertificateSubject = "/O=Sterfive/L=Orleans/C=FR";
OPCUACertificateManager.registry = new node_opcua_object_registry_1.ObjectRegistry({});
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
const opts = { multiArgs: false };
OPCUACertificateManager.prototype.checkCertificate = thenify.withCallback(OPCUACertificateManager.prototype.checkCertificate, opts);
OPCUACertificateManager.prototype.getTrustStatus = thenify.withCallback(OPCUACertificateManager.prototype.getTrustStatus, opts);
OPCUACertificateManager.prototype.initialize = thenify.withCallback(OPCUACertificateManager.prototype.initialize, opts);
function getDefaultCertificateManager(name) {
    const config = (0, env_paths_1.default)("node-opcua-default").config;
    const pkiFolder = path.join(config, name);
    return new OPCUACertificateManager({
        name,
        rootFolder: pkiFolder,
        automaticallyAcceptUnknownCertificate: true
    });
}
exports.getDefaultCertificateManager = getDefaultCertificateManager;
//# sourceMappingURL=certificate_manager.js.map