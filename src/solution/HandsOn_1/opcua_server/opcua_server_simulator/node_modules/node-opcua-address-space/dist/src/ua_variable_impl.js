"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UAVariableImplT = exports.UAVariableImpl = exports.adjust_userAccessLevel = exports.adjust_accessLevel = void 0;
/* eslint-disable max-statements */
/* eslint-disable complexity */
/**
 * @module node-opcua-address-space
 */
// tslint:disable:no-bitwise
// tslint:disable:no-console
// tslint:disable:max-line-length
const chalk = require("chalk");
const node_opcua_address_space_base_1 = require("node-opcua-address-space-base");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_date_time_1 = require("node-opcua-date-time");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_numeric_range_1 = require("node-opcua-numeric-range");
const node_opcua_service_write_1 = require("node-opcua-service-write");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_types_1 = require("node-opcua-types");
const utils = require("node-opcua-utils");
const node_opcua_variant_1 = require("node-opcua-variant");
const session_context_1 = require("../source/session_context");
const multiform_func_1 = require("../source/helpers/multiform_func");
const base_node_impl_1 = require("./base_node_impl");
const base_node_private_1 = require("./base_node_private");
const ua_data_type_impl_1 = require("./ua_data_type_impl");
const apply_condition_refresh_1 = require("./apply_condition_refresh");
const ua_variable_impl_ext_obj_1 = require("./ua_variable_impl_ext_obj");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
function isGoodish(statusCode) {
    return statusCode.value < 0x10000000;
}
function adjust_accessLevel(accessLevel) {
    accessLevel = utils.isNullOrUndefined(accessLevel) ? "CurrentRead | CurrentWrite" : accessLevel;
    accessLevel = (0, node_opcua_data_model_1.makeAccessLevelFlag)(accessLevel);
    (0, node_opcua_assert_1.assert)(isFinite(accessLevel));
    return accessLevel;
}
exports.adjust_accessLevel = adjust_accessLevel;
function adjust_userAccessLevel(userAccessLevel, accessLevel) {
    if (userAccessLevel === undefined) {
        return undefined;
    }
    userAccessLevel = adjust_accessLevel(userAccessLevel);
    accessLevel = adjust_accessLevel(accessLevel);
    return (0, node_opcua_data_model_1.makeAccessLevelFlag)(accessLevel & userAccessLevel);
}
exports.adjust_userAccessLevel = adjust_userAccessLevel;
function adjust_samplingInterval(minimumSamplingInterval) {
    (0, node_opcua_assert_1.assert)(isFinite(minimumSamplingInterval));
    if (minimumSamplingInterval < 0) {
        return -1; // only -1 is a valid negative value for samplingInterval and means "unspecified"
    }
    return minimumSamplingInterval;
}
function is_Variant(v) {
    return v instanceof node_opcua_variant_1.Variant;
}
function is_StatusCode(v) {
    return (v &&
        v.constructor &&
        (v.constructor.name === "ConstantStatusCode" ||
            v.constructor.name === "StatusCode" ||
            v.constructor.name === "ModifiableStatusCode"));
}
function is_Variant_or_StatusCode(v) {
    if (is_Variant(v)) {
        // /@@assert(v.isValid());
    }
    return is_Variant(v) || is_StatusCode(v);
}
function _dataType_toUADataType(addressSpace, dataType) {
    (0, node_opcua_assert_1.assert)(addressSpace);
    (0, node_opcua_assert_1.assert)(dataType !== node_opcua_variant_1.DataType.Null);
    const dataTypeNode = addressSpace.findDataType(node_opcua_variant_1.DataType[dataType]);
    /* istanbul ignore next */
    if (!dataTypeNode) {
        throw new Error(" Cannot find DataType " + node_opcua_variant_1.DataType[dataType] + " in address Space");
    }
    return dataTypeNode;
}
/*=
 *
 * @param addressSpace
 * @param dataTypeNodeId : the nodeId matching the dataType of the destination variable.
 * @param variantDataType: the dataType of the variant to write to the destination variable
 * @param nodeId
 * @return {boolean} true if the variant dataType is compatible with the Variable DataType
 */
function validateDataType(addressSpace, dataTypeNodeId, variantDataType, nodeId, allowNulls) {
    if (variantDataType === node_opcua_variant_1.DataType.ExtensionObject) {
        return true;
    }
    if (variantDataType === node_opcua_variant_1.DataType.Null && allowNulls) {
        return true;
    }
    if (variantDataType === node_opcua_variant_1.DataType.Null && !allowNulls) {
        return false;
    }
    let builtInType;
    let builtInUADataType;
    const destUADataType = addressSpace.findDataType(dataTypeNodeId);
    (0, node_opcua_assert_1.assert)(destUADataType instanceof ua_data_type_impl_1.UADataTypeImpl);
    if (destUADataType.isAbstract || destUADataType.nodeId.namespace !== 0) {
        builtInUADataType = destUADataType;
    }
    else {
        builtInType = addressSpace.findCorrespondingBasicDataType(destUADataType);
        builtInUADataType = addressSpace.findDataType(builtInType);
    }
    (0, node_opcua_assert_1.assert)(builtInUADataType instanceof ua_data_type_impl_1.UADataTypeImpl);
    const enumerationUADataType = addressSpace.findDataType("Enumeration");
    if (!enumerationUADataType) {
        throw new Error("cannot find Enumeration DataType node in standard address space");
    }
    if (destUADataType.isSupertypeOf(enumerationUADataType)) {
        // istanbul ignore next
        if (doDebug) {
            debugLog("destUADataType.", destUADataType.browseName.toString(), destUADataType.nodeId.toString());
            debugLog("enumerationUADataType.", enumerationUADataType.browseName.toString(), enumerationUADataType.nodeId.toString());
        }
        return true;
    }
    // The value supplied for the attribute is not of the same type as the  value.
    const variantUADataType = _dataType_toUADataType(addressSpace, variantDataType);
    (0, node_opcua_assert_1.assert)(variantUADataType instanceof ua_data_type_impl_1.UADataTypeImpl);
    const dest_isSuperTypeOf_variant = variantUADataType.isSupertypeOf(builtInUADataType);
    /* istanbul ignore next */
    if (doDebug) {
        if (dest_isSuperTypeOf_variant) {
            /* istanbul ignore next*/
            debugLog(chalk.green(" ---------- Type match !!! "), " on ", nodeId.toString());
        }
        else {
            /* istanbul ignore next*/
            debugLog(chalk.red(" ---------- Type mismatch "), " on ", nodeId.toString());
        }
        debugLog(chalk.cyan(" Variable data Type is    = "), destUADataType.browseName.toString());
        debugLog(chalk.cyan(" which matches basic Type = "), builtInUADataType.browseName.toString());
        debugLog(chalk.yellow("        Actual   dataType = "), variantUADataType.browseName.toString());
    }
    return dest_isSuperTypeOf_variant;
}
function default_func(dataValue1, callback1) {
    return _default_writable_timestamped_set_func.call(this, dataValue1, callback1);
}
/**
 * A OPCUA Variable Node
 *
 * @class UAVariable
 * @constructor
 * @extends  BaseNode
 *  The AccessLevel Attribute is used to indicate how the Value of a Variable can be accessed (read/write) and if it
 *  contains current and/or historic data. The AccessLevel does not take any user access rights into account,
 *  i.e. although the Variable is writable this may be restricted to a certain user / user group.
 *  The AccessLevel is an 8-bit unsigned integer with the structure defined in the following table:
 *
 *  Field            Bit    Description
 *  CurrentRead      0      Indicates if the current value is readable
 *                          (0 means not readable, 1 means readable).
 *  CurrentWrite     1      Indicates if the current value is writable
 *                          (0 means not writable, 1 means writable).
 *  HistoryRead      2      Indicates if the history of the value is readable
 *                          (0 means not readable, 1 means readable).
 *  HistoryWrite     3      Indicates if the history of the value is writable (0 means not writable, 1 means writable).
 *  SemanticChange   4      Indicates if the Variable used as Property generates SemanticChangeEvents (see 9.31).
 *  Reserved         5:7    Reserved for future use. Shall always be zero.
 *
 *  The first two bits also indicate if a current value of this Variable is available and the second two bits
 *  indicates if the history of the Variable is available via the OPC UA server.
 *
 */
class UAVariableImpl extends base_node_impl_1.BaseNodeImpl {
    constructor(options) {
        super(options);
        this.nodeClass = node_opcua_data_model_1.NodeClass.Variable;
        (0, node_opcua_variant_1.verifyRankAndDimensions)(options);
        this.valueRank = options.valueRank;
        this.arrayDimensions = options.arrayDimensions;
        this.dataType = this.resolveNodeId(options.dataType); // DataType (NodeId)
        this.accessLevel = adjust_accessLevel(options.accessLevel);
        this.userAccessLevel = adjust_userAccessLevel(options.userAccessLevel, this.accessLevel);
        this.minimumSamplingInterval = adjust_samplingInterval(options.minimumSamplingInterval || 0);
        this.historizing = !!options.historizing; // coerced to boolean"
        this.$dataValue = new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.UncertainInitialValue, value: { dataType: node_opcua_variant_1.DataType.Null } });
        if (options.value) {
            this.bindVariable(options.value);
        }
        this.setMaxListeners(5000);
        this.semantic_version = 0;
    }
    get typeDefinitionObj() {
        return super.typeDefinitionObj;
    }
    get typeDefinition() {
        return super.typeDefinition;
    }
    checkPermissionAndAccessLevelPrivate(context, permission, accessLevel) {
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        if (context.checkPermission) {
            (0, node_opcua_assert_1.assert)(context.checkPermission instanceof Function);
            if (!context.checkPermission(this, permission)) {
                return false;
            }
        }
        if (this.userAccessLevel === undefined) {
            return true;
        }
        return (this.userAccessLevel & accessLevel) === accessLevel;
    }
    isReadable(context) {
        return (this.accessLevel & node_opcua_data_model_1.AccessLevelFlag.CurrentRead) === node_opcua_data_model_1.AccessLevelFlag.CurrentRead;
    }
    isUserReadable(context) {
        if (!this.isReadable(context)) {
            return false;
        }
        return this.checkPermissionAndAccessLevelPrivate(context, node_opcua_types_1.PermissionType.Read, node_opcua_data_model_1.AccessLevelFlag.CurrentRead);
    }
    isWritable(context) {
        return (this.accessLevel & node_opcua_data_model_1.AccessLevelFlag.CurrentWrite) === node_opcua_data_model_1.AccessLevelFlag.CurrentWrite;
    }
    isUserWritable(context) {
        if (!this.isWritable(context)) {
            return false;
        }
        return this.checkPermissionAndAccessLevelPrivate(context, node_opcua_types_1.PermissionType.Write, node_opcua_data_model_1.AccessLevelFlag.CurrentWrite);
    }
    /**
     *
     *
     * from OPC.UA.Spec 1.02 part 4
     *  5.10.2.4 StatusCodes
     *  Table 51 defines values for the operation level statusCode contained in the DataValue structure of
     *  each values element. Common StatusCodes are defined in Table 166.
     *
     * Table 51 Read Operation Level Result Codes
     *
     *  Symbolic Id                 Description
     *
     *  BadNodeIdInvalid            The syntax of the node id is not valid.
     *  BadNodeIdUnknown            The node id refers to a node that does not exist in the server address space.
     *  BadAttributeIdInvalid       BadAttributeIdInvalid The attribute is not supported for the specified node.
     *  BadIndexRangeInvalid        The syntax of the index range parameter is invalid.
     *  BadIndexRangeNoData         No data exists within the range of indexes specified.
     *  BadDataEncodingInvalid      The data encoding is invalid.
     *                              This result is used if no dataEncoding can be applied because an Attribute other
     *                              than Value was requested or the DataType of the Value Attribute is not a subtype
     *                              of the Structure DataType.
     *  BadDataEncodingUnsupported  The server does not support the requested data encoding for the node.
     *                              This result is used if a dataEncoding can be applied but the passed data encoding
     *                              is not known to the Server.
     *  BadNotReadable              The access level does not allow reading or subscribing to the Node.
     *  BadUserAccessDenied         User does not have permission to perform the requested operation. (table 165)
     */
    readValue(context, indexRange, dataEncoding) {
        if (!context) {
            context = session_context_1.SessionContext.defaultContext;
        }
        if (context.isAccessRestricted(this)) {
            return new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadSecurityModeInsufficient });
        }
        if (!this.isReadable(context)) {
            return new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadNotReadable });
        }
        if (!this.isUserReadable(context)) {
            return new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadUserAccessDenied });
        }
        if (!(0, node_opcua_data_model_1.isValidDataEncoding)(dataEncoding)) {
            return new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadDataEncodingInvalid });
        }
        if (this._timestamped_get_func) {
            if (this._timestamped_get_func.length === 0) {
                const dataValueOrPromise = this._timestamped_get_func();
                if (!Object.prototype.hasOwnProperty.call(dataValueOrPromise, "then")) {
                    this.$dataValue = dataValueOrPromise;
                    this.verifyVariantCompatibility(this.$dataValue.value);
                }
                else {
                    errorLog("Unsupported: _timestamped_get_func returns a Promise !");
                }
            }
        }
        let dataValue = this.$dataValue;
        if (isGoodish(dataValue.statusCode)) {
            // note : extractRange will clone the dataValue
            dataValue = (0, node_opcua_data_value_1.extractRange)(dataValue, indexRange);
        }
        /* istanbul ignore next */
        if (dataValue.statusCode.equals(node_opcua_status_code_1.StatusCodes.BadWaitingForInitialData) ||
            dataValue.statusCode.equals(node_opcua_status_code_1.StatusCodes.UncertainInitialValue)) {
            debugLog(chalk.red(" Warning:  UAVariable#readValue ") +
                chalk.cyan(this.browseName.toString()) +
                " (" +
                chalk.yellow(this.nodeId.toString()) +
                ") exists but dataValue has not been defined");
        }
        return dataValue;
    }
    isEnumeration() {
        return this.addressSpacePrivate.isEnumeration(this.dataType);
    }
    isExtensionObject() {
        // DataType must be one of Structure
        const dataTypeNode = this.addressSpace.findDataType(this.dataType);
        if (!dataTypeNode) {
            throw new Error(" Cannot find  DataType  " + this.dataType.toString() + " in standard address Space");
        }
        const structureNode = this.addressSpace.findDataType("Structure");
        if (!structureNode) {
            throw new Error(" Cannot find 'Structure' DataType in standard address Space");
        }
        return dataTypeNode.isSupertypeOf(structureNode);
    }
    _getEnumerationInfo() {
        // DataType must be one of Enumeration
        (0, node_opcua_assert_1.assert)(this.isEnumeration(), "Variable is not an enumeration");
        const dataTypeNode = this.addressSpace.findDataType(this.dataType);
        return dataTypeNode._getEnumerationInfo();
    }
    asyncRefresh(...args) {
        if (isGoodish(this.$dataValue.statusCode)) {
            this.verifyVariantCompatibility(this.$dataValue.value);
        }
        const oldestDate = args[0];
        (0, node_opcua_assert_1.assert)(oldestDate instanceof Date);
        const callback = args[1];
        if (!this.refreshFunc) {
            // no refresh func
            const dataValue = this.readValue();
            dataValue.serverTimestamp = oldestDate;
            dataValue.serverPicoseconds = 0;
            if (oldestDate.getTime() <= dataValue.serverTimestamp.getTime()) {
                return callback(null, dataValue);
            }
            else {
                // fake
                return callback(null, dataValue);
            }
        }
        if (this.$dataValue.serverTimestamp && oldestDate.getTime() <= this.$dataValue.serverTimestamp.getTime()) {
            const dataValue = this.readValue();
            dataValue.serverTimestamp = oldestDate;
            dataValue.serverPicoseconds = 0;
            return callback(null, dataValue);
        }
        try {
            this.refreshFunc.call(this, (err, dataValue) => {
                if (err || !dataValue) {
                    errorLog("-------------- refresh call failed", this.browseName.toString(), this.nodeId.toString(), err === null || err === void 0 ? void 0 : err.message);
                    dataValue = { statusCode: node_opcua_status_code_1.StatusCodes.BadNoDataAvailable };
                }
                if (dataValue !== this.$dataValue) {
                    this._internal_set_dataValue(coerceDataValue(dataValue), null);
                }
                callback(err, this.$dataValue);
            });
        }
        catch (err) {
            errorLog("-------------- refresh call failed 2", this.browseName.toString(), this.nodeId.toString());
            errorLog(err);
            const dataValue = new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadInternalError });
            this._internal_set_dataValue(dataValue, null);
            callback(err, this.$dataValue);
        }
    }
    readEnumValue() {
        const value = this.readValue().value.value;
        const enumInfo = this._getEnumerationInfo();
        const enumV = enumInfo.valueIndex[value];
        return { value, name: enumV ? enumV.name : "?????" };
    }
    writeEnumValue(value) {
        const enumInfo = this._getEnumerationInfo();
        if (typeof value === "string") {
            if (!Object.prototype.hasOwnProperty.call(enumInfo.nameIndex, value)) {
                const possibleValues = Object.keys(enumInfo.nameIndex).join(",");
                throw new Error("UAVariable#writeEnumValue: cannot find value " + value + " in [" + possibleValues + "]");
            }
            const valueIndex = enumInfo.nameIndex[value].value;
            value = valueIndex;
        }
        if (isFinite(value)) {
            const possibleValues = Object.keys(enumInfo.nameIndex).join(",");
            if (!enumInfo.valueIndex[value]) {
                throw new Error("UAVariable#writeEnumValue : value out of range " + value + " in [" + possibleValues + "]");
            }
            this.setValueFromSource({
                dataType: node_opcua_variant_1.DataType.Int32,
                value
            });
        }
        else {
            throw new Error("UAVariable#writeEnumValue:  value type mismatch");
        }
    }
    readAttribute(context, attributeId, indexRange, dataEncoding) {
        context = context || session_context_1.SessionContext.defaultContext;
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        const options = {};
        if (attributeId !== node_opcua_data_model_1.AttributeIds.Value) {
            if (indexRange && indexRange.isDefined()) {
                options.statusCode = node_opcua_status_code_1.StatusCodes.BadIndexRangeNoData;
                return new node_opcua_data_value_1.DataValue(options);
            }
            if ((0, node_opcua_data_model_1.isDataEncoding)(dataEncoding)) {
                options.statusCode = node_opcua_status_code_1.StatusCodes.BadDataEncodingInvalid;
                return new node_opcua_data_value_1.DataValue(options);
            }
        }
        switch (attributeId) {
            case node_opcua_data_model_1.AttributeIds.Value:
                return this.readValue(context, indexRange, dataEncoding);
            case node_opcua_data_model_1.AttributeIds.DataType:
                return this._readDataType();
            case node_opcua_data_model_1.AttributeIds.ValueRank:
                return this._readValueRank();
            case node_opcua_data_model_1.AttributeIds.ArrayDimensions:
                return this._readArrayDimensions();
            case node_opcua_data_model_1.AttributeIds.AccessLevel:
                return this._readAccessLevel(context);
            case node_opcua_data_model_1.AttributeIds.UserAccessLevel:
                return this._readUserAccessLevel(context);
            case node_opcua_data_model_1.AttributeIds.MinimumSamplingInterval:
                return this._readMinimumSamplingInterval();
            case node_opcua_data_model_1.AttributeIds.Historizing:
                return this._readHistorizing();
            case node_opcua_data_model_1.AttributeIds.AccessLevelEx:
                return this._readAccessLevelEx(context);
            default:
                return base_node_impl_1.BaseNodeImpl.prototype.readAttribute.call(this, context, attributeId);
        }
    }
    getBasicDataType() {
        if (this._basicDataType) {
            return this._basicDataType;
        }
        if (this.dataType.namespace === 0 && this.dataType.value === 0) {
            return node_opcua_variant_1.DataType.Null;
        }
        const addressSpace = this.addressSpace;
        if (!addressSpace) {
            // may be node has been deleted already
            return node_opcua_variant_1.DataType.Null;
        }
        const dataTypeNode = addressSpace.findDataType(this.dataType);
        const basicDataType = dataTypeNode && dataTypeNode.nodeClass === node_opcua_data_model_1.NodeClass.DataType ? dataTypeNode.getBasicDataType() : node_opcua_variant_1.DataType.Null;
        // const basicDataType = addressSpace.findCorrespondingBasicDataType(this.dataType);
        this._basicDataType = basicDataType;
        return basicDataType;
    }
    adjustVariant(variant) {
        return (0, node_opcua_variant_1.adjustVariant)(variant, this.valueRank, this.getBasicDataType());
    }
    verifyVariantCompatibility(variant) {
        try {
            // istanbul ignore next
            if (Object.prototype.hasOwnProperty.call(variant, "value")) {
                if (variant.dataType === null || variant.dataType === undefined) {
                    throw new Error("Variant must provide a valid dataType : variant = " +
                        variant.toString() +
                        " this.dataType= " +
                        this.dataType.toString());
                }
                if (variant.dataType === node_opcua_variant_1.DataType.Boolean &&
                    (this.dataType.namespace !== 0 || this.dataType.value !== node_opcua_variant_1.DataType.Boolean)) {
                    throw new Error("Variant must provide a valid Boolean : variant = " +
                        variant.toString() +
                        " this.dataType= " +
                        this.dataType.toString());
                }
                if (this.dataType.namespace === 0 &&
                    this.dataType.value === node_opcua_variant_1.DataType.LocalizedText &&
                    variant.dataType !== node_opcua_variant_1.DataType.LocalizedText &&
                    variant.dataType !== node_opcua_variant_1.DataType.Null) {
                    throw new Error("Variant must provide a valid LocalizedText : variant = " +
                        variant.toString() +
                        " this.dataType= " +
                        this.dataType.toString());
                }
            }
            const basicType = this.getBasicDataType();
            if (basicType === node_opcua_variant_1.DataType.String && variant.dataType === node_opcua_variant_1.DataType.ByteString) {
                return; // this is allowed
            }
            if (basicType === node_opcua_variant_1.DataType.ByteString && variant.dataType === node_opcua_variant_1.DataType.String) {
                return; // this is allowed
            }
            if (basicType !== node_opcua_variant_1.DataType.Null &&
                basicType !== node_opcua_variant_1.DataType.Variant &&
                variant.dataType !== node_opcua_variant_1.DataType.Null &&
                variant.dataType !== basicType) {
                const message = "UAVariable.setValueFromSource " +
                    this.browseName.toString() +
                    " nodeId:" +
                    this.nodeId.toString() +
                    " dataType:" +
                    this.dataType.toString() +
                    ":\n" +
                    "the provided variant must have the expected dataType!\n" +
                    "   - the expected dataType is " +
                    chalk.cyan(node_opcua_variant_1.DataType[basicType]) +
                    "\n" +
                    "   - the actual dataType   is " +
                    chalk.magenta(node_opcua_variant_1.DataType[variant.dataType]) +
                    "\n" +
                    "   - " +
                    variant.toString();
                throw new Error(message);
            }
        }
        catch (err) {
            errorLog("UAVariable  ", err === null || err === void 0 ? void 0 : err.message, this.browseName.toString(), " nodeId=", this.nodeId.toString());
            errorLog(err.message);
            errorLog(err.stack);
            throw err;
        }
    }
    /**
     * setValueFromSource is used to let the device sets the variable values
     * this method also records the current time as sourceTimestamp and serverTimestamp.
.     *
     * The method will raise an exception if the value is not compatible with the dataType and expected dimension
     *
     * @method setValueFromSource
     * @param variant  {Variant}
     * @param [statusCode  {StatusCode} = StatusCodes.Good]
     * @param [sourceTimestamp= Now]
     */
    setValueFromSource(variant, statusCode, sourceTimestamp) {
        var _a;
        try {
            statusCode = statusCode || node_opcua_status_code_1.StatusCodes.Good;
            const variant1 = node_opcua_variant_1.Variant.coerce(variant);
            this.verifyVariantCompatibility(variant1);
            const now = (0, node_opcua_date_time_1.coerceClock)(sourceTimestamp, 0);
            const dataValue = new node_opcua_data_value_1.DataValue(null);
            dataValue.serverPicoseconds = now.picoseconds;
            dataValue.serverTimestamp = now.timestamp;
            dataValue.sourcePicoseconds = now.picoseconds;
            dataValue.sourceTimestamp = now.timestamp;
            dataValue.statusCode = statusCode;
            dataValue.value = variant1;
            if (dataValue.value.dataType === node_opcua_variant_1.DataType.ExtensionObject) {
                const valueIsCorrect = this.checkExtensionObjectIsCorrect(dataValue.value.value);
                if (!valueIsCorrect) {
                    errorLog("Invalid value !");
                    errorLog(this.toString());
                    errorLog(dataValue.toString());
                    this.checkExtensionObjectIsCorrect(dataValue.value.value);
                }
                this.$dataValue = dataValue;
                // ----------------------------------
                if (this.$extensionObject) {
                    // we have an extension object already bound to this node
                    // the client is asking us to replace the object entierly by a new one
                    const ext = dataValue.value.value;
                    (0, ua_variable_impl_ext_obj_1._setExtensionObject)(this, ext);
                    return;
                }
            }
            else {
                this._internal_set_dataValue(dataValue);
            }
        }
        catch (err) {
            errorLog("UAVariable#setValueFromString Error : ", this.browseName.toString(), this.nodeId.toString());
            errorLog(err.message);
            errorLog((_a = this.parent) === null || _a === void 0 ? void 0 : _a.toString());
            throw err;
        }
    }
    writeValue(context, dataValue, ...args) {
        context = context || session_context_1.SessionContext.defaultContext;
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        if (!dataValue.sourceTimestamp) {
            // source timestamp was not specified by the caller
            // we will set the timestamp ourself with the current clock
            if (context.currentTime) {
                dataValue.sourceTimestamp = context.currentTime.timestamp;
                dataValue.sourcePicoseconds = context.currentTime.picoseconds;
            }
            else {
                const { timestamp, picoseconds } = (0, node_opcua_date_time_1.getCurrentClock)();
                dataValue.sourceTimestamp = timestamp;
                dataValue.sourcePicoseconds = picoseconds;
            }
        }
        if (context.currentTime && !dataValue.serverTimestamp) {
            dataValue.serverTimestamp = context.currentTime.timestamp;
            dataValue.serverPicoseconds = context.currentTime.picoseconds;
        }
        // adjust arguments if optional indexRange Parameter is not given
        let indexRange = null;
        let callback;
        if (args.length === 1) {
            indexRange = new node_opcua_numeric_range_1.NumericRange();
            callback = args[0];
        }
        else if (args.length === 2) {
            indexRange = args[0];
            callback = args[1];
        }
        else {
            throw new Error("Invalid Number of args");
        }
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        (0, node_opcua_assert_1.assert)(dataValue instanceof node_opcua_data_value_1.DataValue);
        // index range could be string
        indexRange = node_opcua_numeric_range_1.NumericRange.coerce(indexRange);
        // test write permission
        if (!this.isWritable(context)) {
            return callback(null, node_opcua_status_code_1.StatusCodes.BadNotWritable);
        }
        if (!this.isUserWritable(context)) {
            return callback(null, node_opcua_status_code_1.StatusCodes.BadUserAccessDenied);
        }
        // adjust special case
        const variant = adjustVariant2.call(this, dataValue.value);
        const statusCode = this.checkVariantCompatibility(variant);
        if (statusCode.isNot(node_opcua_status_code_1.StatusCodes.Good)) {
            return callback(null, statusCode);
        }
        const write_func = this._timestamped_set_func || default_func;
        if (!write_func) {
            warningLog(" warning " + this.nodeId.toString() + " " + this.browseName.toString() + " has no setter. \n");
            warningLog("Please make sure to bind the variable or to pass a valid value: new Variant({}) during construction time");
            return callback(null, node_opcua_status_code_1.StatusCodes.BadNotWritable);
        }
        (0, node_opcua_assert_1.assert)(write_func);
        write_func.call(this, dataValue, (err, statusCode1) => {
            if (!err) {
                dataValue && this.verifyVariantCompatibility(dataValue.value);
                if (indexRange && !indexRange.isEmpty()) {
                    if (!indexRange.isValid()) {
                        return callback(null, node_opcua_status_code_1.StatusCodes.BadIndexRangeInvalid);
                    }
                    const newArrayOrMatrix = dataValue.value.value;
                    if (dataValue.value.arrayType === node_opcua_variant_1.VariantArrayType.Array) {
                        if (this.$dataValue.value.arrayType !== node_opcua_variant_1.VariantArrayType.Array) {
                            return callback(null, node_opcua_status_code_1.StatusCodes.BadTypeMismatch);
                        }
                        // check that destination data is also an array
                        (0, node_opcua_assert_1.assert)(check_valid_array(this.$dataValue.value.dataType, this.$dataValue.value.value));
                        const destArr = this.$dataValue.value.value;
                        const result = indexRange.set_values(destArr, newArrayOrMatrix);
                        if (result.statusCode.isNot(node_opcua_status_code_1.StatusCodes.Good)) {
                            return callback(null, result.statusCode);
                        }
                        dataValue.value.value = result.array;
                        // scrap original array so we detect range
                        this.$dataValue.value.value = null;
                    }
                    else if (dataValue.value.arrayType === node_opcua_variant_1.VariantArrayType.Matrix) {
                        const dimensions = this.$dataValue.value.dimensions;
                        if (this.$dataValue.value.arrayType !== node_opcua_variant_1.VariantArrayType.Matrix || !dimensions) {
                            // not a matrix !
                            return callback(null, node_opcua_status_code_1.StatusCodes.BadTypeMismatch);
                        }
                        const matrix = this.$dataValue.value.value;
                        const result = indexRange.set_values_matrix({
                            matrix,
                            dimensions
                        }, newArrayOrMatrix);
                        if (result.statusCode.isNot(node_opcua_status_code_1.StatusCodes.Good)) {
                            return callback(null, result.statusCode);
                        }
                        dataValue.value.dimensions = this.$dataValue.value.dimensions;
                        dataValue.value.value = result.matrix;
                        // scrap original array so we detect range
                        this.$dataValue.value.value = null;
                    }
                    else {
                        return callback(null, node_opcua_status_code_1.StatusCodes.BadTypeMismatch);
                    }
                }
                try {
                    this._internal_set_dataValue(dataValue, indexRange);
                }
                catch (err) {
                    if (err instanceof Error) {
                        warningLog(err.message);
                    }
                    return callback(null, node_opcua_status_code_1.StatusCodes.BadInternalError);
                }
            }
            callback(err || null, statusCode1);
        });
    }
    writeAttribute(context, writeValueOptions, callback) {
        // istanbul ignore next
        if (!callback) {
            throw new Error("Internal error");
        }
        const writeValue = writeValueOptions instanceof node_opcua_service_write_1.WriteValue ? writeValueOptions : new node_opcua_service_write_1.WriteValue(writeValueOptions);
        context = context || session_context_1.SessionContext.defaultContext;
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        (0, node_opcua_assert_1.assert)(writeValue instanceof node_opcua_service_write_1.WriteValue);
        (0, node_opcua_assert_1.assert)(writeValue.value instanceof node_opcua_data_value_1.DataValue);
        (0, node_opcua_assert_1.assert)(writeValue.value.value instanceof node_opcua_variant_1.Variant);
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        // Spec 1.0.2 Part 4 page 58
        // If the SourceTimestamp or the ServerTimestamp is specified, the Server shall
        // use these values.
        // xx _apply_default_timestamps(writeValue.value);
        switch (writeValue.attributeId) {
            case node_opcua_data_model_1.AttributeIds.Value:
                this.writeValue(context, writeValue.value, writeValue.indexRange, callback);
                break;
            case node_opcua_data_model_1.AttributeIds.Historizing:
                if (writeValue.value.value.dataType !== node_opcua_variant_1.DataType.Boolean) {
                    return callback(null, node_opcua_status_code_1.StatusCodes.BadNotSupported);
                }
                // if the variable has no historizing in place reject
                if (!this["hA Configuration"]) {
                    return callback(null, node_opcua_status_code_1.StatusCodes.BadNotSupported);
                }
                // check if user is allowed to do that !
                // TODO
                this.historizing = !!writeValue.value.value.value; // yes ! indeed !
                return callback(null, node_opcua_status_code_1.StatusCodes.Good);
            default:
                super.writeAttribute(context, writeValue, callback);
                break;
        }
    }
    /**
     * @method checkVariantCompatibility
     * note:
     *     this method is overridden in address-space-data-access
     * @return {StatusCode}
     */
    checkVariantCompatibility(value) {
        // test dataType
        if (!this._validate_DataType(value.dataType)) {
            return node_opcua_status_code_1.StatusCodes.BadTypeMismatch;
        }
        try {
            this.verifyVariantCompatibility(value);
        }
        catch (err) {
            return node_opcua_status_code_1.StatusCodes.BadTypeMismatch;
        }
        return node_opcua_status_code_1.StatusCodes.Good;
    }
    /**
     * touch the source timestamp of a Variable and cascade up the change
     * to the parent variable if any.
     */
    touchValue(optionalNow) {
        const now = optionalNow || (0, node_opcua_date_time_1.getCurrentClock)();
        (0, ua_variable_impl_ext_obj_1.propagateTouchValueUpward)(this, now);
    }
    /**
     * bind a variable with a get and set functions.
     *
     *  properties:
     *    - value: a Variant or a status code
     *    - sourceTimestamp
     *    - sourcePicoseconds
     * @param [options.timestamped_set]
     * @param [options.refreshFunc]      the variable asynchronous getter function.
     * @param [overwrite {Boolean} = false] set overwrite to true to overwrite existing binding
     * @return void
     *
     *
     * ### Providing read access to the underlying value
     *
     * #### Variation 1
     *
     * In this variation, the user provides a function that returns a Variant with the current value.
     *
     * The sourceTimestamp will be set automatically.
     *
     * The get function is called synchronously.
     *
     * @example
     *
     *
     * ```javascript
     *     ...
     *     var options =  {
     *       get : () => {
     *          return new Variant({...});
     *       },
     *       set : function(variant) {
     *          // store the variant somewhere
     *          return StatusCodes.Good;
     *       }
     *    };
     *    ...
     *    engine.bindVariable(nodeId,options):
     *    ...
     * ```
     *
     *
     * #### Variation 2:
     *
     * This variation can be used when the user wants to specify a specific '''sourceTimestamp''' associated
     * with the current value of the UAVariable.
     *
     * The provided ```timestamped_get``` function should return an object with three properties:
     * * value: containing the variant value or a error StatusCode,
     * * sourceTimestamp
     * * sourcePicoseconds
     *
     * ```javascript
     * ...
     * var myDataValue = new DataValue({
     *   value: {dataType: DataType.Double , value: 10.0},
     *   sourceTimestamp : new Date(),
     *   sourcePicoseconds: 0
     * });
     * ...
     * var options =  {
     *   timestamped_get : () => { return myDataValue;  }
     * };
     * ...
     * engine.bindVariable(nodeId,options):
     * ...
     * // record a new value
     * myDataValue.value.value = 5.0;
     * myDataValue.sourceTimestamp = new Date();
     * ...
     * ```
     *
     *
     * #### Variation 3:
     *
     * This variation can be used when the value associated with the variables requires a asynchronous function call to be
     * extracted. In this case, the user should provide an async method ```refreshFunc```.
     *
     *
     * The ```refreshFunc``` shall do whatever is necessary to fetch the most up to date version of the variable value, and
     * call the ```callback``` function when the data is ready.
     *
     *
     * The ```callback``` function follow the standard callback function signature:
     * * the first argument shall be **null** or **Error**, depending of the outcome of the fetch operation,
     * * the second argument shall be a DataValue with the new UAVariable Value,  a StatusCode, and time stamps.
     *
     *
     * Optionally, it is possible to pass a sourceTimestamp and a sourcePicoseconds value as a third and fourth arguments
     * of the callback. When sourceTimestamp and sourcePicoseconds are missing, the system will set their default value
     * to the current time..
     *
     *
     * ```javascript
     * ...
     * var options =  {
     *    refreshFunc : function(callback) {
     *      ... do_some_async_stuff_to_get_the_new_variable_value
     *      var dataValue = new DataValue({
     *          value: new Variant({...}),
     *          statusCode: StatusCodes.Good,
     *          sourceTimestamp: new Date()
     *      });
     *      callback(null,dataValue);
     *    }
     * };
     * ...
     * variable.bindVariable(nodeId,options):
     * ...
     * ```
     *
     * ### Providing write access to the underlying value
     *
     * #### Variation1 - provide a simple synchronous set function
     *
     *
     * #### Notes
     *   to do : explain return StatusCodes.GoodCompletesAsynchronously;
     *
     */
    bindVariable(options, overwrite) {
        if (overwrite) {
            this._timestamped_set_func = null;
            this._timestamped_get_func = null;
            this._get_func = null;
            this._set_func = null;
            this.refreshFunc = undefined;
            this._historyRead = UAVariableImpl.prototype._historyRead;
        }
        options = options || {};
        (0, node_opcua_assert_1.assert)(typeof this._timestamped_set_func !== "function", "UAVariable already bound");
        (0, node_opcua_assert_1.assert)(typeof this._timestamped_get_func !== "function", "UAVariable already bound");
        bind_getter.call(this, options);
        bind_setter.call(this, options);
        const _historyRead = options.historyRead;
        if (_historyRead) {
            (0, node_opcua_assert_1.assert)(typeof this._historyRead !== "function" || this._historyRead === UAVariableImpl.prototype._historyRead);
            (0, node_opcua_assert_1.assert)(typeof _historyRead === "function");
            this._historyRead = _historyRead;
            (0, node_opcua_assert_1.assert)(this._historyRead.length === 6);
        }
        // post conditions
        (0, node_opcua_assert_1.assert)(typeof this._timestamped_set_func === "function");
        (0, node_opcua_assert_1.assert)(this._timestamped_set_func.length === 2, "expecting 2 parameters");
    }
    readValueAsync(context, callback) {
        if (!context) {
            context = session_context_1.SessionContext.defaultContext;
        }
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        this.__waiting_callbacks = this.__waiting_callbacks || [];
        this.__waiting_callbacks.push(callback);
        const _readValueAsync_in_progress = this.__waiting_callbacks.length >= 2;
        if (_readValueAsync_in_progress) {
            return;
        }
        const readImmediate = (innerCallback) => {
            (0, node_opcua_assert_1.assert)(this.$dataValue instanceof node_opcua_data_value_1.DataValue);
            const dataValue = this.readValue();
            innerCallback(null, dataValue);
        };
        let func;
        if (!this.isReadable(context)) {
            func = (innerCallback) => {
                const dataValue = new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadNotReadable });
                innerCallback(null, dataValue);
            };
        }
        else if (!this.isUserReadable(context)) {
            func = (innerCallback) => {
                const dataValue = new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadUserAccessDenied });
                innerCallback(null, dataValue);
            };
        }
        else {
            func = typeof this.refreshFunc === "function" ? this.asyncRefresh.bind(this, new Date()) : readImmediate;
        }
        const satisfy_callbacks = (err, dataValue) => {
            // now call all pending callbacks
            const callbacks = this.__waiting_callbacks || [];
            this.__waiting_callbacks = [];
            const n = callbacks.length;
            for (const callback1 of callbacks) {
                callback1.call(this, err, dataValue);
            }
        };
        try {
            func.call(this, satisfy_callbacks);
        }
        catch (err) {
            // istanbul ignore next
            if (doDebug) {
                debugLog(chalk.red("func readValueAsync has failed "));
                if (err instanceof Error) {
                    debugLog(" stack", err.stack);
                }
            }
            satisfy_callbacks(err);
        }
    }
    getWriteMask() {
        return super.getWriteMask();
    }
    getUserWriteMask() {
        return super.getUserWriteMask();
    }
    clone(options, optionalFilter, extraInfo) {
        options = Object.assign(Object.assign({}, options), { 
            // check this eventNotifier: this.eventNotifier,
            // check this symbolicName: this.symbolicName,
            accessLevel: this.accessLevel, arrayDimensions: this.arrayDimensions, dataType: this.dataType, historizing: this.historizing, minimumSamplingInterval: this.minimumSamplingInterval, userAccessLevel: this.userAccessLevel, valueRank: this.valueRank });
        const newVariable = base_node_private_1._clone.call(this, UAVariableImpl, options, optionalFilter || node_opcua_address_space_base_1.defaultCloneFilter, extraInfo || node_opcua_address_space_base_1.defaultCloneExtraInfo);
        newVariable.bindVariable();
        (0, node_opcua_assert_1.assert)(typeof newVariable._timestamped_set_func === "function");
        (0, node_opcua_assert_1.assert)(newVariable.dataType === this.dataType);
        newVariable.$dataValue = this.$dataValue.clone();
        // also bind extension object
        const v = newVariable.$dataValue.value;
        if (v.dataType === node_opcua_variant_1.DataType.ExtensionObject && v.value && v.arrayType === node_opcua_variant_1.VariantArrayType.Scalar) {
            try {
                newVariable.bindExtensionObject(newVariable.$dataValue.value.value);
            }
            catch (err) {
                errorLog("Errro binding extension objects");
                errorLog(err.message);
                errorLog(this.toString());
                errorLog("---------------------------------------");
                errorLog(this.$dataValue.toString());
                errorLog("---------------------------------------");
                errorLog(newVariable.$dataValue.toString());
                throw err;
            }
        }
        return newVariable;
    }
    getDataTypeNode() {
        const addressSpace = this.addressSpace;
        const dt = addressSpace.findNode(this.dataType);
        // istanbul ignore next
        if (!dt) {
            throw new Error("getDataTypeNode: cannot find dataType " + this.dataType.toString());
        }
        return dt;
    }
    get dataTypeObj() {
        return this.getDataTypeNode();
    }
    checkExtensionObjectIsCorrect(extObj) {
        if (!extObj) {
            return true;
        }
        const addressSpace = this.addressSpace;
        const dataType = addressSpace.findDataType(this.dataType);
        if (!dataType) {
            // may be we are in the process of loading a xml file and the corresponding dataType
            // has not yet been loaded !
            return true;
        }
        const Constructor = addressSpace.getExtensionObjectConstructor(this.dataType);
        if (this.valueRank === -1) {
            /** Scalar */
            if (extObj instanceof Array) {
                return false;
            }
            return checkExtensionObjectIsCorrectScalar.call(this, extObj);
        }
        else if (this.valueRank === 1) {
            /** array */
            if (!(extObj instanceof Array)) {
                // let's coerce this scalar into an 1-element array if it is a valid extension object
                if (checkExtensionObjectIsCorrectScalar.call(this, extObj)) {
                    warningLog(`warning: checkExtensionObjectIsCorrect : expecting a array but got a scalar (value rank of '${this.browseName.toString()}' is 1)\nautomatic conversion from scalar to array with 1 element is taking place.`);
                    extObj = [extObj];
                }
                else {
                    return false;
                }
            }
            return checkExtensionObjectIsCorrectArray.call(this, extObj);
        }
        else if (this.valueRank === 0) {
            // Scalar or Array
            const isCorrectScalar = !Array.isArray(extObj) && checkExtensionObjectIsCorrectScalar.call(this, extObj);
            const isCorrectArray = Array.isArray(extObj) && checkExtensionObjectIsCorrectArray.call(this, extObj);
            return isCorrectArray || isCorrectScalar;
        }
        else {
            throw new Error(`checkExtensionObjectIsCorrect: Not Implemented case, please contact sterfive : this.valueRank =${this.valueRank}`);
        }
        function checkExtensionObjectIsCorrectScalar(extObj) {
            // istanbul ignore next
            if (!(extObj && extObj.constructor)) {
                errorLog(extObj);
                throw new Error("expecting an valid extension object");
            }
            return extObj.constructor.name === Constructor.name;
        }
        function checkExtensionObjectIsCorrectArray(extObjArray) {
            // istanbul ignore next
            for (const extObj of extObjArray) {
                if (!(extObj && extObj.constructor)) {
                    errorLog(extObj);
                    throw new Error("expecting an valid extension object");
                }
            }
            try {
                for (const e of extObjArray) {
                    if (!e) {
                        continue;
                    }
                    if (e.constructor.name !== Constructor.name) {
                        debugLog("extObj.constructor.name ", e.constructor.name, "expected", Constructor.name);
                        return false;
                    }
                }
                return true;
            }
            catch (err) {
                errorLog(err);
                return false;
            }
        }
    }
    /**
     * @private
     * install UAVariable to exposed th
     *
     * precondition:
     */
    installExtensionObjectVariables() {
        (0, ua_variable_impl_ext_obj_1._installExtensionObjectBindingOnProperties)(this, { createMissingProp: true });
        // now recursively install extension object on children
        for (const child of this.getComponents()) {
            if (child.nodeClass === node_opcua_data_model_1.NodeClass.Variable && child instanceof UAVariableImpl) {
                if (child.isExtensionObject()) {
                    child.installExtensionObjectVariables();
                }
            }
        }
    }
    /**
     * @method bindExtensionObject
     * @return {ExtensionObject}
     */
    bindExtensionObjectScalar(optionalExtensionObject, options) {
        return this.bindExtensionObject(optionalExtensionObject, options);
    }
    bindExtensionObjectArray(optionalExtensionObject, options) {
        return this.bindExtensionObject(optionalExtensionObject, options);
    }
    bindExtensionObject(optionalExtensionObject, options) {
        return (0, ua_variable_impl_ext_obj_1._bindExtensionObject)(this, optionalExtensionObject, options);
    }
    updateExtensionObjectPartial(partialExtensionObject) {
        (0, ua_variable_impl_ext_obj_1.setExtensionObjectValue)(this, partialExtensionObject);
        return this.$extensionObject;
    }
    incrementExtensionObjectPartial(path) {
        const extensionObject = this.readValue().value.value;
        const partialData = (0, ua_variable_impl_ext_obj_1.extractPartialData)(path, extensionObject);
        (0, ua_variable_impl_ext_obj_1.setExtensionObjectValue)(this, partialData);
    }
    toString() {
        const options = new base_node_private_1.ToStringBuilder();
        base_node_private_1.UAVariable_toString.call(this, options);
        return options.toString();
    }
    historyRead(context, historyReadDetails, indexRange, dataEncoding, continuationData, callback) {
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        if (typeof this._historyRead !== "function") {
            return callback(null, new node_opcua_types_1.HistoryReadResult({ statusCode: node_opcua_status_code_1.StatusCodes.BadNotReadable }));
        }
        this._historyRead(context, historyReadDetails, indexRange, dataEncoding, continuationData, callback);
    }
    _historyReadRaw(context, historyReadRawModifiedDetails, indexRange, dataEncoding, continuationData, callback) {
        throw new Error("");
    }
    _historyReadRawModify(context, historyReadRawModifiedDetails, indexRange, dataEncoding, continuationData, callback) {
        throw new Error("");
    }
    _historyRead(context, historyReadDetails, indexRange, dataEncoding, continuationData, callback) {
        const result = new node_opcua_types_1.HistoryReadResult({
            statusCode: node_opcua_status_code_1.StatusCodes.BadHistoryOperationUnsupported
        });
        callback(null, result);
    }
    _historyPush(newDataValue) {
        throw new Error("");
    }
    _historyReadRawAsync(historyReadRawModifiedDetails, maxNumberToExtract, isReversed, reverseDataValue, callback) {
        throw new Error("");
    }
    _historyReadModify(context, historyReadRawModifiedDetails, indexRange, dataEncoding, continuationData, callback) {
        throw new Error("");
    }
    _update_startOfOnlineArchive(newDate) {
        // please install
        throw new Error("");
    }
    _update_startOfArchive(newDate) {
        throw new Error("");
    }
    _validate_DataType(variantDataType) {
        return validateDataType(this.addressSpace, this.dataType, variantDataType, this.nodeId, /* allow Nulls */ false);
    }
    _internal_set_value(value) {
        if (value.dataType !== node_opcua_variant_1.DataType.Null) {
            this.verifyVariantCompatibility(value);
        }
        this.$dataValue.value = value;
    }
    _internal_set_dataValue(dataValue, indexRange) {
        (0, node_opcua_assert_1.assert)(dataValue, "expecting a dataValue");
        (0, node_opcua_assert_1.assert)(dataValue instanceof node_opcua_data_value_1.DataValue, "expecting dataValue to be a DataValue");
        (0, node_opcua_assert_1.assert)(dataValue !== this.$dataValue, "expecting dataValue to be different from previous DataValue instance");
        const addressSpace = this.addressSpace;
        if (!addressSpace) {
            warningLog("UAVariable#_internal_set_dataValue : no addressSpace ! may be node has already been deleted ?");
            return;
        }
        if (dataValue.value.arrayType === node_opcua_variant_1.VariantArrayType.Matrix) {
            if (!dataValue.value.dimensions) {
                throw new Error("missing dimensions: a Matrix Variant needs a dimension");
            }
            const nbElements = dataValue.value.dimensions.reduce((acc, x) => acc * x, 1);
            if (dataValue.value.value.length !== 0 && dataValue.value.value.length !== nbElements) {
                throw new Error(`Internal Error: matrix dimension doesn't match the number of element in the array : ${dataValue.toString()} "\n expecting ${nbElements} elements but got ${dataValue.value.value.length}`);
            }
        }
        if (dataValue.value.dataType === node_opcua_variant_1.DataType.ExtensionObject) {
            if (!this.checkExtensionObjectIsCorrect(dataValue.value.value)) {
                warningLog(dataValue.toString());
                throw new Error("Invalid Extension Object on nodeId =" + this.nodeId.toString());
            }
            // ----------------------------------
            // if (this.$extensionObject) {
            //     // we have an extension object already bound to this node
            //     // the client is asking us to replace the object entierly by a new one
            //     const ext = dataValue.value.value;
            //     _setExtensionObject(this, ext);
            //     return;
            // }
        }
        // // istanbul ignore next
        // if (this.dataType.namespace === 0) {
        //     if (this.dataType.value === DataType.LocalizedText && dataValue.value.dataType !== DataType.LocalizedText) {
        //         const message = "Invalid dataValue provided (expecting a LocalizedText) but got " + dataValue.toString();
        //         errorLog(message);
        //         // throw new Error(message);
        //     }
        // }
        this.verifyVariantCompatibility(dataValue.value);
        const old_dataValue = this.$dataValue;
        this.$dataValue = dataValue;
        this.$dataValue.statusCode = this.$dataValue.statusCode || node_opcua_status_code_1.StatusCodes.Good;
        // repair missing timestamps
        if (!dataValue.serverTimestamp) {
            this.$dataValue.serverTimestamp = old_dataValue.serverTimestamp;
            this.$dataValue.serverPicoseconds = old_dataValue.serverPicoseconds;
        }
        if (!dataValue.sourceTimestamp) {
            this.$dataValue.sourceTimestamp = old_dataValue.sourceTimestamp;
            this.$dataValue.sourcePicoseconds = old_dataValue.sourcePicoseconds;
        }
        if (!(0, node_opcua_data_value_1.sameDataValue)(old_dataValue, dataValue)) {
            this.emit("value_changed", this.$dataValue, indexRange);
        }
    }
    _conditionRefresh(_cache) {
        apply_condition_refresh_1.apply_condition_refresh.call(this, _cache);
    }
    handle_semantic_changed() {
        this.semantic_version = this.semantic_version + 1;
        this.emit("semantic_changed");
    }
    _readDataType() {
        (0, node_opcua_assert_1.assert)(this.dataType instanceof node_opcua_nodeid_1.NodeId);
        const options = {
            statusCode: node_opcua_status_code_1.StatusCodes.Good,
            value: {
                dataType: node_opcua_variant_1.DataType.NodeId,
                value: this.dataType
            }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readValueRank() {
        (0, node_opcua_assert_1.assert)(typeof this.valueRank === "number");
        const options = {
            statusCode: node_opcua_status_code_1.StatusCodes.Good,
            value: { dataType: node_opcua_variant_1.DataType.Int32, value: this.valueRank }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readArrayDimensions() {
        (0, node_opcua_assert_1.assert)(Array.isArray(this.arrayDimensions) || this.arrayDimensions === null);
        (0, node_opcua_assert_1.assert)(!this.arrayDimensions || this.valueRank > 0, "arrayDimension must be null if valueRank <0");
        const options = {
            statusCode: node_opcua_status_code_1.StatusCodes.Good,
            value: { dataType: node_opcua_variant_1.DataType.UInt32, arrayType: node_opcua_variant_1.VariantArrayType.Array, value: this.arrayDimensions }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readAccessLevel(context) {
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        const options = {
            statusCode: node_opcua_status_code_1.StatusCodes.Good,
            value: { dataType: node_opcua_variant_1.DataType.Byte, value: (0, node_opcua_data_model_1.convertAccessLevelFlagToByte)(this.accessLevel) }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readAccessLevelEx(context) {
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        const options = {
            statusCode: node_opcua_status_code_1.StatusCodes.Good,
            // Extra flags are not supported yet. to do:
            value: { dataType: node_opcua_variant_1.DataType.UInt32, value: (0, node_opcua_data_model_1.convertAccessLevelFlagToByte)(this.accessLevel) }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readUserAccessLevel(context) {
        (0, node_opcua_assert_1.assert)(context instanceof session_context_1.SessionContext);
        const effectiveUserAccessLevel = _calculateEffectiveUserAccessLevelFromPermission(this, context, this.userAccessLevel);
        const options = {
            value: {
                dataType: node_opcua_variant_1.DataType.Byte,
                statusCode: node_opcua_status_code_1.StatusCodes.Good,
                value: (0, node_opcua_data_model_1.convertAccessLevelFlagToByte)(effectiveUserAccessLevel)
            }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readMinimumSamplingInterval() {
        // expect a Duration => Double
        const options = {};
        if (this.minimumSamplingInterval === undefined) {
            options.statusCode = node_opcua_status_code_1.StatusCodes.BadAttributeIdInvalid;
        }
        else {
            options.value = { dataType: node_opcua_variant_1.DataType.Double, value: this.minimumSamplingInterval };
            options.statusCode = node_opcua_status_code_1.StatusCodes.Good;
        }
        return new node_opcua_data_value_1.DataValue(options);
    }
    _readHistorizing() {
        (0, node_opcua_assert_1.assert)(typeof this.historizing === "boolean");
        const options = {
            statusCode: node_opcua_status_code_1.StatusCodes.Good,
            value: { dataType: node_opcua_variant_1.DataType.Boolean, value: !!this.historizing }
        };
        return new node_opcua_data_value_1.DataValue(options);
    }
}
exports.UAVariableImpl = UAVariableImpl;
// tslint:disable:no-var-requires
const thenify = require("thenify");
UAVariableImpl.prototype.asyncRefresh = thenify.withCallback(UAVariableImpl.prototype.asyncRefresh);
UAVariableImpl.prototype.writeValue = thenify.withCallback(UAVariableImpl.prototype.writeValue);
UAVariableImpl.prototype.writeAttribute = thenify.withCallback(UAVariableImpl.prototype.writeAttribute);
UAVariableImpl.prototype.historyRead = thenify.withCallback(UAVariableImpl.prototype.historyRead);
UAVariableImpl.prototype.readValueAsync = thenify.withCallback(UAVariableImpl.prototype.readValueAsync);
function check_valid_array(dataType, array) {
    if (Array.isArray(array)) {
        return true;
    }
    switch (dataType) {
        case node_opcua_variant_1.DataType.Double:
            return array instanceof Float64Array;
        case node_opcua_variant_1.DataType.Float:
            return array instanceof Float32Array;
        case node_opcua_variant_1.DataType.Int32:
            return array instanceof Int32Array;
        case node_opcua_variant_1.DataType.Int16:
            return array instanceof Int16Array;
        case node_opcua_variant_1.DataType.SByte:
            return array instanceof Int8Array;
        case node_opcua_variant_1.DataType.UInt32:
            return array instanceof Uint32Array;
        case node_opcua_variant_1.DataType.UInt16:
            return array instanceof Uint16Array;
        case node_opcua_variant_1.DataType.Byte:
            return array instanceof Uint8Array || array instanceof Buffer;
    }
    return false;
}
function _apply_default_timestamps(dataValue) {
    const now = (0, node_opcua_date_time_1.getCurrentClock)();
    (0, node_opcua_assert_1.assert)(dataValue instanceof node_opcua_data_value_1.DataValue);
    if (!dataValue.sourceTimestamp) {
        dataValue.sourceTimestamp = now.timestamp;
        dataValue.sourcePicoseconds = now.picoseconds;
    }
    if (!dataValue.serverTimestamp) {
        dataValue.serverTimestamp = now.timestamp;
        dataValue.serverPicoseconds = now.picoseconds;
    }
}
function unsetFlag(flags, mask) {
    return flags & ~mask;
}
function setFlag(flags, mask) {
    return flags | mask;
}
function _calculateEffectiveUserAccessLevelFromPermission(node, context, userAccessLevel) {
    function __adjustFlag(permissionType, access, userAccessLevel1) {
        if ((node.accessLevel & access) === 0 || (userAccessLevel1 & access) === 0) {
            userAccessLevel1 = unsetFlag(userAccessLevel1, access);
        }
        else {
            if (!context.checkPermission(node, permissionType)) {
                userAccessLevel1 = unsetFlag(userAccessLevel1, access);
            }
        }
        return userAccessLevel1;
    }
    userAccessLevel = node.userAccessLevel === undefined ? node.accessLevel : node.userAccessLevel & node.accessLevel;
    if (context.checkPermission) {
        (0, node_opcua_assert_1.assert)(context.checkPermission instanceof Function);
        userAccessLevel = __adjustFlag(node_opcua_types_1.PermissionType.Read, node_opcua_data_model_1.AccessLevelFlag.CurrentRead, userAccessLevel);
        userAccessLevel = __adjustFlag(node_opcua_types_1.PermissionType.Write, node_opcua_data_model_1.AccessLevelFlag.CurrentWrite, userAccessLevel);
        userAccessLevel = __adjustFlag(node_opcua_types_1.PermissionType.Write, node_opcua_data_model_1.AccessLevelFlag.StatusWrite, userAccessLevel);
        userAccessLevel = __adjustFlag(node_opcua_types_1.PermissionType.Write, node_opcua_data_model_1.AccessLevelFlag.TimestampWrite, userAccessLevel);
        userAccessLevel = __adjustFlag(node_opcua_types_1.PermissionType.ReadHistory, node_opcua_data_model_1.AccessLevelFlag.HistoryRead, userAccessLevel);
        userAccessLevel = __adjustFlag(node_opcua_types_1.PermissionType.DeleteHistory, node_opcua_data_model_1.AccessLevelFlag.HistoryWrite, userAccessLevel);
        return userAccessLevel;
    }
    else {
        return userAccessLevel;
    }
}
function adjustVariant2(variant) {
    // convert Variant( Scalar|ByteString) =>  Variant(Array|ByteArray)
    const addressSpace = this.addressSpace;
    const basicType = this.getBasicDataType();
    variant = (0, node_opcua_variant_1.adjustVariant)(variant, this.valueRank, basicType);
    return variant;
}
function _not_writable_timestamped_set_func(dataValue, callback) {
    (0, node_opcua_assert_1.assert)(dataValue instanceof node_opcua_data_value_1.DataValue);
    callback(null, node_opcua_status_code_1.StatusCodes.BadNotWritable, null);
}
function _default_writable_timestamped_set_func(dataValue, callback) {
    (0, node_opcua_assert_1.assert)(dataValue instanceof node_opcua_data_value_1.DataValue);
    callback(null, node_opcua_status_code_1.StatusCodes.Good, dataValue);
}
function turn_sync_to_async(f, numberOfArgs) {
    if (f.length <= numberOfArgs) {
        return function (data, callback) {
            const r = f.call(this, data);
            setImmediate(() => {
                return callback(null, r);
            });
        };
    }
    else {
        (0, node_opcua_assert_1.assert)(f.length === numberOfArgs + 1);
        return f;
    }
}
const _default_minimumSamplingInterval = 1000;
function coerceDataValue(dataValue) {
    if (dataValue instanceof node_opcua_data_value_1.DataValue) {
        return dataValue;
    }
    return new node_opcua_data_value_1.DataValue(dataValue);
}
// variation #3 :
function _Variable_bind_with_async_refresh(options) {
    /* jshint validthis: true */
    (0, node_opcua_assert_1.assert)(this instanceof UAVariableImpl);
    (0, node_opcua_assert_1.assert)(typeof options.refreshFunc === "function");
    (0, node_opcua_assert_1.assert)(!options.get, "a getter shall not be specified when refreshFunc is set");
    (0, node_opcua_assert_1.assert)(!options.timestamped_get, "a getter shall not be specified when refreshFunc is set");
    (0, node_opcua_assert_1.assert)(!this.refreshFunc);
    this.refreshFunc = options.refreshFunc;
    // assert(this.readValue().statusCode === StatusCodes.BadNodeIdUnknown);
    this.$dataValue.statusCode = node_opcua_status_code_1.StatusCodes.UncertainInitialValue;
    // TO DO : REVISIT THIS ASSUMPTION
    if (false && this.minimumSamplingInterval === 0) {
        // when a getter /timestamped_getter or async_getter is provided
        // samplingInterval cannot be 0, as the item value must be scanned to be updated.
        this.minimumSamplingInterval = _default_minimumSamplingInterval; // MonitoredItem.minimumSamplingInterval;
        debugLog("adapting minimumSamplingInterval on " + this.browseName.toString() + " to " + this.minimumSamplingInterval);
    }
}
// variation 2
function _Variable_bind_with_timestamped_get(options) {
    /* jshint validthis: true */
    (0, node_opcua_assert_1.assert)(this instanceof UAVariableImpl);
    (0, node_opcua_assert_1.assert)(typeof options.timestamped_get === "function");
    (0, node_opcua_assert_1.assert)(!options.get, "should not specify 'get' when 'timestamped_get' exists ");
    (0, node_opcua_assert_1.assert)(!this._timestamped_get_func);
    const async_refresh_func = (callback) => {
        Promise.resolve(this._timestamped_get_func.call(this))
            .then((dataValue) => callback(null, dataValue))
            .catch((err) => {
            errorLog("asyncRefresh error: Variable is  ", this.nodeId.toString(), this.browseName.toString());
            callback(err);
        });
    };
    const pThis = this;
    if (options.timestamped_get.length === 0) {
        const timestamped_get = options.timestamped_get;
        // sync version | Promise version
        this._timestamped_get_func = timestamped_get;
        const dataValue_verify = timestamped_get.call(pThis);
        // dataValue_verify should be a DataValue or a Promise
        /* istanbul ignore next */
        if (!(dataValue_verify instanceof node_opcua_data_value_1.DataValue) && typeof dataValue_verify.then !== "function") {
            errorLog(chalk.red(" Bind variable error: "), " the timestamped_get function must return a DataValue or a Promise<DataValue>" +
                "\n value_check.constructor.name ", dataValue_verify ? dataValue_verify.constructor.name : "null");
            throw new Error(" Bind variable error: " + " the timestamped_get function must return a DataValue");
        }
        _Variable_bind_with_async_refresh.call(this, { refreshFunc: async_refresh_func });
    }
    else if (options.timestamped_get.length === 1) {
        _Variable_bind_with_async_refresh.call(this, { refreshFunc: options.timestamped_get });
    }
    else {
        errorLog("timestamped_get has a invalid number of argument , should be 0 or 1  ");
        throw new Error("timestamped_get has a invalid number of argument , should be 0 or 1  ");
    }
}
// variation 1
function _Variable_bind_with_simple_get(options) {
    /* jshint validthis: true */
    (0, node_opcua_assert_1.assert)(this instanceof UAVariableImpl);
    (0, node_opcua_assert_1.assert)(typeof options.get === "function", "should specify get function");
    (0, node_opcua_assert_1.assert)(options.get.length === 0, "get function should not have arguments");
    (0, node_opcua_assert_1.assert)(!options.timestamped_get, "should not specify a timestamped_get function when get is specified");
    (0, node_opcua_assert_1.assert)(!this._timestamped_get_func);
    (0, node_opcua_assert_1.assert)(!this._get_func);
    this._get_func = options.get;
    const timestamped_get_func_from__Variable_bind_with_simple_get = () => {
        const value = this._get_func();
        /* istanbul ignore next */
        if (!is_Variant_or_StatusCode(value)) {
            errorLog(chalk.red(" Bind variable error: "), " : the getter must return a Variant or a StatusCode" + "\nvalue_check.constructor.name ", value ? value.constructor.name : "null");
            throw new Error(" bindVariable : the value getter function returns a invalid result ( expecting a Variant or a StatusCode !!!");
        }
        if (is_StatusCode(value)) {
            return new node_opcua_data_value_1.DataValue({ statusCode: value });
        }
        else {
            if (!this.$dataValue || !isGoodish(this.$dataValue.statusCode) || !(0, node_opcua_variant_1.sameVariant)(this.$dataValue.value, value)) {
                this.setValueFromSource(value, node_opcua_status_code_1.StatusCodes.Good);
            }
            return this.$dataValue;
        }
    };
    _Variable_bind_with_timestamped_get.call(this, {
        get: undefined,
        timestamped_get: timestamped_get_func_from__Variable_bind_with_simple_get
    });
}
function _Variable_bind_with_simple_set(options) {
    (0, node_opcua_assert_1.assert)(this instanceof UAVariableImpl);
    (0, node_opcua_assert_1.assert)(typeof options.set === "function", "should specify set function");
    (0, node_opcua_assert_1.assert)(!options.timestamped_set, "should not specify a timestamped_set function");
    (0, node_opcua_assert_1.assert)(!this._timestamped_set_func);
    (0, node_opcua_assert_1.assert)(!this._set_func);
    this._set_func = turn_sync_to_async(options.set, 1);
    (0, node_opcua_assert_1.assert)(this._set_func.length === 2, " set function must have 2 arguments ( variant, callback)");
    this._timestamped_set_func = (timestamped_value, callback) => {
        (0, node_opcua_assert_1.assert)(timestamped_value instanceof node_opcua_data_value_1.DataValue);
        this._set_func(timestamped_value.value, (err, statusCode) => {
            // istanbul ignore next
            if (!err && !statusCode) {
                errorLog(chalk.red("UAVariable Binding Error _set_func must return a StatusCode, check the bindVariable parameters"));
                errorLog(chalk.yellow("StatusCode.Good is assumed"));
                return callback(err, node_opcua_status_code_1.StatusCodes.Good, timestamped_value);
            }
            callback(err, statusCode, timestamped_value);
        });
    };
}
function _Variable_bind_with_timestamped_set(options) {
    (0, node_opcua_assert_1.assert)(typeof options.timestamped_set === "function");
    (0, node_opcua_assert_1.assert)(options.timestamped_set.length === 2, "timestamped_set must have 2 parameters  timestamped_set: function(dataValue,callback){}");
    (0, node_opcua_assert_1.assert)(!options.set, "should not specify set when timestamped_set_func exists ");
    this._timestamped_set_func = (0, multiform_func_1.convertToCallbackFunction1)(options.timestamped_set);
}
function bind_setter(options) {
    if (typeof options.set === "function") {
        // variation 1
        _Variable_bind_with_simple_set.call(this, options);
    }
    else if (typeof options.timestamped_set === "function") {
        // variation 2
        (0, node_opcua_assert_1.assert)(typeof options.timestamped_get === "function", "timestamped_set must be used with timestamped_get ");
        _Variable_bind_with_timestamped_set.call(this, {
            set: undefined,
            timestamped_set: options.timestamped_set
        });
    }
    else if (typeof options.timestamped_get === "function") {
        // timestamped_get is  specified but timestamped_set is not
        // => Value is read-only
        _Variable_bind_with_timestamped_set.call(this, {
            set: undefined,
            timestamped_set: _not_writable_timestamped_set_func
        });
    }
    else {
        _Variable_bind_with_timestamped_set.call(this, {
            set: undefined,
            timestamped_set: _default_writable_timestamped_set_func
        });
    }
}
function bind_getter(options) {
    if (typeof options.get === "function") {
        // variation 1
        _Variable_bind_with_simple_get.call(this, options);
    }
    else if (typeof options.timestamped_get === "function") {
        // variation 2
        _Variable_bind_with_timestamped_get.call(this, {
            get: undefined,
            timestamped_get: options.timestamped_get
        });
    }
    else if (typeof options.refreshFunc === "function") {
        // variation 3
        _Variable_bind_with_async_refresh.call(this, options);
    }
    else {
        (0, node_opcua_assert_1.assert)(!Object.prototype.hasOwnProperty.call(options, "set"), "getter is missing : a getter must be provided if a setter is provided");
        // xx bind_variant.call(this,options);
        if (options.dataType !== undefined) {
            // if (options.dataType !== DataType.ExtensionObject) {
            this.setValueFromSource(options);
            // }
        }
    }
}
class UAVariableImplT extends UAVariableImpl {
}
exports.UAVariableImplT = UAVariableImplT;
// x TO DO
// require("./data_access/ua_variable_data_access");
// require("./historical_access/ua_variable_history");
//# sourceMappingURL=ua_variable_impl.js.map