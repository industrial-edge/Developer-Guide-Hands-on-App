"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructNamespaceDependency = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const base_node_impl_1 = require("../base_node_impl");
function _constructNamespaceDependency(namespace, dependency, depMap, _visitedDataType) {
    const addressSpace = namespace.addressSpace;
    const namespace_ = namespace;
    // navigate all namespace recursively to
    function consider(namespaceIndex) {
        if (!depMap.has(namespaceIndex)) {
            depMap.add(namespaceIndex);
            const namespace = addressSpace.getNamespace(namespaceIndex);
            dependency.push(namespace);
            if (namespaceIndex > 0) {
                _constructNamespaceDependency(namespace, dependency, depMap, _visitedDataType);
            }
        }
    }
    function exploreDataTypeField(field) {
        const dataType = field.dataType;
        const namespaceIndex = dataType.namespace;
        consider(namespaceIndex);
        const dataTypeNode = addressSpace.findDataType(field.dataType);
        if (dataTypeNode) {
            exploreDataTypes(dataTypeNode);
        }
    }
    function exploreDataTypes(dataTypeNode) {
        const dataType = dataTypeNode.nodeId;
        if (_visitedDataType.has(dataType.toString())) {
            return;
        }
        const namespaceIndex = dataType.namespace;
        consider(namespaceIndex);
        if (dataTypeNode.isStructure()) {
            const definition = dataTypeNode.getStructureDefinition();
            for (const field of definition.fields || []) {
                exploreDataTypeField(field);
            }
        }
        _visitedDataType.add(dataType.toString());
    }
    for (const node of namespace_.nodeIterator()) {
        if (node.nodeClass === node_opcua_data_model_1.NodeClass.Variable || node.nodeClass === node_opcua_data_model_1.NodeClass.VariableType) {
            const dataTypeNodeId = node.dataType;
            const dataTypeNode = addressSpace.findDataType(dataTypeNodeId);
            if (dataTypeNode) {
                exploreDataTypes(dataTypeNode);
            }
            else {
                // istanbul ignore next
                if (dataTypeNodeId.value != 0) {
                    console.log("Internal error: Cannot find dataType", dataTypeNodeId.toString());
                }
            }
        }
        // visit all references
        const references = node.ownReferences();
        for (const reference of references) {
            // check referenceId
            const namespaceIndex = (0, base_node_impl_1.getReferenceType)(reference).nodeId.namespace;
            consider(namespaceIndex);
            const namespaceIndex2 = reference.nodeId.namespace;
            consider(namespaceIndex2);
        }
    }
}
function constructNamespaceDependency(namespace) {
    const addressSpace = namespace.addressSpace;
    const dependency = [];
    const depMap = new Set();
    dependency.push(addressSpace.getDefaultNamespace());
    depMap.add(0);
    if (namespace !== addressSpace.getDefaultNamespace()) {
        dependency.push(namespace);
        depMap.add(namespace.index);
    }
    const _visitedDataType = new Set();
    _constructNamespaceDependency(namespace, dependency, depMap, _visitedDataType);
    return dependency;
}
exports.constructNamespaceDependency = constructNamespaceDependency;
//# sourceMappingURL=construct_namespace_dependency.js.map