"use strict";
/**
 * @module node_opcua_crypto
 */
// ---------------------------------------------------------------------------------------------------------------------
// crypto_explore_certificate
// ---------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2014-2020 - Etienne Rossignon
// ---------------------------------------------------------------------------------------------------------------------
//
// This  project is licensed under the terms of the MIT license.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so,  subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//
// ---------------------------------------------------------------------------------------------------------------------
// ASN.1 JavaScript decoder Copyright (c) 2008-2014 Lapo Luchini lapo@lapo.it
// Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby
// granted, provided that the above copyright notice and this permission notice appear in all copies.
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
// ---------------------------------------------------------------------------------------------------------------------
/*jslint bitwise: true */
// tslint:disable:no-shadowed-variable
Object.defineProperty(exports, "__esModule", { value: true });
exports.combine_der = exports.split_der = exports.exploreCertificate = exports.readTbsCertificate = exports._readExtension = void 0;
// references:
//  - http://tools.ietf.org/html/rfc5280
//  - http://www-lor.int-evry.fr/~michel/Supports/presentation.pdf
//  - ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc
//  - pubs.opengroup.org/onlinepubs/009609799/7a_nch02.htm#tagcjh_49_03
//  - https://github.com/lapo-luchini/asn1js/blob/master/asn1.js
//  - http://lapo.it/asn1js
//  - https://www.cs.auckland.ac.nz/~pgut001/dumpasn1.cfg
//  - http://pubs.opengroup.org/onlinepubs/009609799/7a_nch02.htm
//  - http://stackoverflow.com/questions/5929050/how-does-asn-1-encode-an-object-identifier
//  - http://luca.ntop.org/Teaching/Appunti/asn1.html
// note:
//  - http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art030
//  openssl can be also used to discover the content of a DER file
//  $ openssl asn1parse -in cert.pem
const assert = require("assert");
const asn1_1 = require("./asn1");
const crypto_utils_1 = require("./crypto_utils");
// Converted from: https://www.cs.auckland.ac.nz/~pgut001/dumpasn1.cfg
// which is made by Peter Gutmann and whose license states:
// You can use this code in whatever way you want,
// as long as you don't try to claim you wrote it.
const doDebug = false;
function _readAttributeTypeAndValue(buffer, block) {
    let inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    inner_blocks = (0, asn1_1._readStruct)(buffer, inner_blocks[0]);
    const data = {
        identifier: (0, asn1_1._readObjectIdentifier)(buffer, inner_blocks[0]).name,
        value: (0, asn1_1._readValue)(buffer, inner_blocks[1]),
    };
    const result = {};
    for (const [key, value] of Object.entries(data)) {
        result[key] = value;
    }
    return result;
}
function _readRelativeDistinguishedName(buffer, block) {
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    const data = inner_blocks.map((block) => _readAttributeTypeAndValue(buffer, block));
    const result = {};
    for (const e of data) {
        result[e.identifier] = e.value;
    }
    return result;
}
function _readName(buffer, block) {
    return _readRelativeDistinguishedName(buffer, block);
}
function _readValidity(buffer, block) {
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    return {
        notBefore: (0, asn1_1._readTime)(buffer, inner_blocks[0]),
        notAfter: (0, asn1_1._readTime)(buffer, inner_blocks[1]),
    };
}
function _readAuthorityKeyIdentifier(buffer) {
    /**
     *  where a CA distributes its public key in the form of a "self-signed"
     *  certificate, the authority key identifier MAY be omitted.  Th
     *  signature on a self-signed certificate is generated with the private
     * key associated with the certificate's subject public key.  (This
     * proves that the issuer possesses both the public and private keys.)
     * In this case, the subject and authority key identifiers would be
     * identical, but only the subject key identifier is needed for
     * certification path building.
     */
    // see: https://www.ietf.org/rfc/rfc3280.txt page 25
    // AuthorityKeyIdentifier ::= SEQUENCE {
    //      keyIdentifier             [0] KeyIdentifier           OPTIONAL,
    //      authorityCertIssuer       [1] GeneralNames            OPTIONAL,
    //      authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
    // KeyIdentifier ::= OCTET STRING
    const block_info = (0, asn1_1.readTag)(buffer, 0);
    const blocks = (0, asn1_1._readStruct)(buffer, block_info);
    const keyIdentifier_block = (0, asn1_1._findBlockAtIndex)(blocks, 0);
    const authorityCertIssuer_block = (0, asn1_1._findBlockAtIndex)(blocks, 1);
    const authorityCertSerialNumber_block = (0, asn1_1._findBlockAtIndex)(blocks, 2);
    function _readAuthorityCertIssuer(block) {
        const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
        const directoryName_block = (0, asn1_1._findBlockAtIndex)(inner_blocks, 4);
        if (directoryName_block) {
            const a = (0, asn1_1._readStruct)(buffer, directoryName_block);
            return (0, asn1_1._readDirectoryName)(buffer, a[0]);
        }
        else {
            throw new Error("Invalid _readAuthorityCertIssuer");
        }
    }
    function _readAuthorityCertIssuerFingerPrint(block) {
        const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
        const directoryName_block = (0, asn1_1._findBlockAtIndex)(inner_blocks, 4);
        if (!directoryName_block) {
            return "";
        }
        const a = (0, asn1_1._readStruct)(buffer, directoryName_block);
        if (a.length < 1) {
            return "";
        }
        return directoryName_block ? (0, asn1_1.formatBuffer2DigitHexWithColum)((0, crypto_utils_1.makeSHA1Thumbprint)((0, asn1_1._getBlock)(buffer, a[0]))) : "";
    }
    const authorityCertIssuer = authorityCertIssuer_block ? _readAuthorityCertIssuer(authorityCertIssuer_block) : null;
    const authorityCertIssuerFingerPrint = authorityCertIssuer_block
        ? _readAuthorityCertIssuerFingerPrint(authorityCertIssuer_block)
        : "";
    return {
        authorityCertIssuer,
        authorityCertIssuerFingerPrint,
        serial: authorityCertSerialNumber_block
            ? (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._getBlock)(buffer, authorityCertSerialNumber_block))
            : null,
        keyIdentifier: keyIdentifier_block ? (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._getBlock)(buffer, keyIdentifier_block)) : null, // can be null for self-signed certf
    };
}
/*
 Extension  ::=  SEQUENCE  {
        extnID      OBJECT IDENTIFIER,
        critical    BOOLEAN DEFAULT FALSE,
        extnValue   OCTET STRING
                    -- contains the DER encoding of an ASN.1 value
                    -- corresponding to the extension type identified
                    -- by extnID
        }

      id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }

      KeyUsage ::= BIT STRING {
           digitalSignature        (0),
           nonRepudiation          (1), -- recent editions of X.509 have
                                -- renamed this bit to contentCommitment
           keyEncipherment         (2),
           dataEncipherment        (3),
           keyAgreement            (4),
           keyCertSign             (5),
           cRLSign                 (6),
           encipherOnly            (7),
           decipherOnly            (8) }

extKeyUsage
*/
function readBasicConstraint2_5_29_19(buffer, block) {
    const block_info = (0, asn1_1.readTag)(buffer, 0);
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block_info);
    const cA = inner_blocks.length > 0 ? (0, asn1_1._readBooleanValue)(buffer, inner_blocks[0]) : false;
    //    console.log("buffer[block_info.position] = ", buffer[block_info.position]);
    // const cA = buffer[block_info.position] ? true : false;
    let pathLengthConstraint = 0;
    if (inner_blocks.length > 1) {
        pathLengthConstraint = (0, asn1_1._readIntegerValue)(buffer, inner_blocks[1]);
    }
    return { critical: true, cA, pathLengthConstraint };
}
// GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
// GeneralName ::= CHOICE {
//        otherName                 [0]  AnotherName,
//        rfc822Name                [1]  IA5String,
//        dNSName                   [2]  IA5String,
//        x400Address               [3]  ORAddress,
//        directoryName             [4]  Name,
//        ediPartyName              [5]  EDIPartyName,
//        uniformResourceIdentifier [6]  IA5String,
//        iPAddress                 [7]  OCTET STRING,
//        registeredID              [8]  OBJECT IDENTIFIER }
function _readGeneralNames(buffer, block) {
    const _data = {
        1: { name: "rfc822Name", type: "IA5String" },
        2: { name: "dNSName", type: "IA5String" },
        3: { name: "x400Address", type: "ORAddress" },
        4: { name: "directoryName", type: "Name" },
        5: { name: "ediPartyName", type: "EDIPartyName" },
        6: { name: "uniformResourceIdentifier", type: "IA5String" },
        7: { name: "iPAddress", type: "OCTET_STRING" },
        8: { name: "registeredID", type: "OBJECT_IDENTIFIER" },
    };
    const blocks = (0, asn1_1._readStruct)(buffer, block);
    function _readFromType(buffer, block, type) {
        switch (type) {
            case "IA5String":
                return buffer.slice(block.position, block.position + block.length).toString("ascii");
            default:
                return buffer.slice(block.position, block.position + block.length).toString("hex");
        }
    }
    const n = {};
    for (const block of blocks) {
        // tslint:disable-next-line: no-bitwise
        assert((block.tag & 0x80) === 0x80);
        // tslint:disable-next-line: no-bitwise
        const t = block.tag & 0x7f;
        const type = _data[t];
        // istanbul ignore next
        if (!type) {
            throw new Error(" INVALID TYPE => " + t + "0x" + t.toString(16));
        }
        n[type.name] = n[type.name] || [];
        n[type.name].push(_readFromType(buffer, block, type.type));
    }
    return n;
}
function _readSubjectAltNames(buffer) {
    const block_info = (0, asn1_1.readTag)(buffer, 0);
    return _readGeneralNames(buffer, block_info);
}
function readKeyUsage(oid, buffer) {
    const block_info = (0, asn1_1.readTag)(buffer, 0);
    // get value as BIT STRING
    let b2 = 0x00;
    let b3 = 0x00;
    if (block_info.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = buffer[block_info.position + 1];
        b3 = block_info.length > 2 ? buffer[block_info.position + 2] : 0;
    }
    // set flags
    return {
        // tslint:disable-next-line: no-bitwise
        digitalSignature: (b2 & 0x80) === 0x80,
        // tslint:disable-next-line: no-bitwise
        nonRepudiation: (b2 & 0x40) === 0x40,
        // tslint:disable-next-line: no-bitwise
        keyEncipherment: (b2 & 0x20) === 0x20,
        // tslint:disable-next-line: no-bitwise
        dataEncipherment: (b2 & 0x10) === 0x10,
        // tslint:disable-next-line: no-bitwise
        keyAgreement: (b2 & 0x08) === 0x08,
        // tslint:disable-next-line: no-bitwise
        keyCertSign: (b2 & 0x04) === 0x04,
        // tslint:disable-next-line: no-bitwise
        cRLSign: (b2 & 0x02) === 0x02,
        // tslint:disable-next-line: no-bitwise
        encipherOnly: (b2 & 0x01) === 0x01,
        // tslint:disable-next-line: no-bitwise
        decipherOnly: (b3 & 0x80) === 0x80,
    };
}
function readExtKeyUsage(oid, buffer) {
    assert(oid === "2.5.29.37");
    // see https://tools.ietf.org/html/rfc5280#section-4.2.1.12
    const block_info = (0, asn1_1.readTag)(buffer, 0);
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block_info);
    const extKeyUsage = {
        serverAuth: false,
        clientAuth: false,
        codeSigning: false,
        emailProtection: false,
        timeStamping: false,
        ipsecEndSystem: false,
        ipsecTunnel: false,
        ipsecUser: false,
        ocspSigning: false,
    };
    for (const block of inner_blocks) {
        const identifier = (0, asn1_1._readObjectIdentifier)(buffer, block);
        extKeyUsage[identifier.name] = true;
    }
    /*
    
   id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }

   id-kp-serverAuth             OBJECT IDENTIFIER ::= { id-kp 1 }
   -- TLS WWW server authentication
   -- Key usage bits that may be consistent: digitalSignature,
   -- keyEncipherment or keyAgreement

   id-kp-clientAuth             OBJECT IDENTIFIER ::= { id-kp 2 }
   -- TLS WWW client authentication
   -- Key usage bits that may be consistent: digitalSignature
   -- and/or keyAgreement

   id-kp-codeSigning             OBJECT IDENTIFIER ::= { id-kp 3 }
   -- Signing of downloadable executable code
   -- Key usage bits that may be consistent: digitalSignature

   id-kp-emailProtection         OBJECT IDENTIFIER ::= { id-kp 4 }
   -- Email protection
   -- Key usage bits that may be consistent: digitalSignature,
   -- nonRepudiation, and/or (keyEncipherment or keyAgreement)

   id-kp-timeStamping            OBJECT IDENTIFIER ::= { id-kp 8 }
   -- Binding the hash of an object to a time
   -- Key usage bits that may be consistent: digitalSignature
   -- and/or nonRepudiation

   id-kp-OCSPSigning            OBJECT IDENTIFIER ::= { id-kp 9 }
   -- Signing OCSP responses
   -- Key usage bits that may be consistent: digitalSignature
   -- and/or nonRepudiation

   */
    // set flags
    return extKeyUsage;
}
function _readSubjectPublicKey(buffer) {
    const block_info = (0, asn1_1.readTag)(buffer, 0);
    const blocks = (0, asn1_1._readStruct)(buffer, block_info);
    return {
        modulus: buffer.slice(blocks[0].position + 1, blocks[0].position + blocks[0].length),
    };
}
/*
 Extension  ::=  SEQUENCE  {
 extnID      OBJECT IDENTIFIER,
 critical    BOOLEAN DEFAULT FALSE,
 extnValue   OCTET STRING
 -- contains the DER encoding of an ASN.1 value
 -- corresponding to the extension type identified
 -- by extnID
 }
 */
function _readExtension(buffer, block) {
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    if (inner_blocks.length === 3) {
        assert(inner_blocks[1].tag === asn1_1.TagType.BOOLEAN);
        inner_blocks[1] = inner_blocks[2];
    }
    const identifier = (0, asn1_1._readObjectIdentifier)(buffer, inner_blocks[0]);
    const buf = (0, asn1_1._getBlock)(buffer, inner_blocks[1]);
    let value = null;
    switch (identifier.name) {
        case "subjectKeyIdentifier":
            /* from https://tools.ietf.org/html/rfc3280#section-4.1 :
               For CA certificates, subject key identifiers SHOULD be derived from
               the public key or a method that generates unique values.  Two common
               methods for generating key identifiers from the public key are:

                  (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
                  value of the BIT STRING subjectPublicKey (excluding the tag,
                  length, and number of unused bits).

                  (2) The keyIdentifier is composed of a four bit type field with
                  the value 0100 followed by the least significant 60 bits of the
                  SHA-1 hash of the value of the BIT STRING subjectPublicKey
                  (excluding the tag, length, and number of unused bit string bits).
            */
            value = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._readOctetString)(buffer, inner_blocks[1]));
            break;
        case "subjectAltName":
            value = _readSubjectAltNames(buf);
            break;
        case "authorityKeyIdentifier":
            value = _readAuthorityKeyIdentifier(buf);
            break;
        case "basicConstraints":
            value = readBasicConstraint2_5_29_19(buf, inner_blocks[1]); //  "2.5.29.19":
            // "basicConstraints ( not implemented yet) " + buf.toString("hex");
            break;
        case "certExtension": // Netscape
            value = "basicConstraints ( not implemented yet) " + buf.toString("hex");
            break;
        case "extKeyUsage":
            value = readExtKeyUsage(identifier.oid, buf);
            break;
        case "keyUsage":
            value = readKeyUsage(identifier.oid, buf);
            break;
        default:
            value = "Unknown " + identifier.name + buf.toString("hex");
    }
    return {
        identifier,
        value,
    };
}
exports._readExtension = _readExtension;
// Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
function _readExtensions(buffer, block) {
    assert(block.tag === 0xa3);
    let inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    inner_blocks = (0, asn1_1._readStruct)(buffer, inner_blocks[0]);
    const extensions = inner_blocks.map((block) => _readExtension(buffer, block));
    const result = {};
    for (const e of extensions) {
        result[e.identifier.name] = e.value;
    }
    return result;
}
/*
 SEQUENCE {
 204   13:       SEQUENCE {
 206    9:         OBJECT IDENTIFIER
 :           rsaEncryption (1 2 840 113549 1 1 1)
 217    0:         NULL
 :         }
 219  141:       BIT STRING, encapsulates {
 223  137:         SEQUENCE {
 226  129:           INTEGER
 :             00 C2 D7 97 6D 28 70 AA 5B CF 23 2E 80 70 39 EE
 :             DB 6F D5 2D D5 6A 4F 7A 34 2D F9 22 72 47 70 1D
 :             EF 80 E9 CA 30 8C 00 C4 9A 6E 5B 45 B4 6E A5 E6
 :             6C 94 0D FA 91 E9 40 FC 25 9D C7 B7 68 19 56 8F
 :             11 70 6A D7 F1 C9 11 4F 3A 7E 3F 99 8D 6E 76 A5
 :             74 5F 5E A4 55 53 E5 C7 68 36 53 C7 1D 3B 12 A6
 :             85 FE BD 6E A1 CA DF 35 50 AC 08 D7 B9 B4 7E 5C
 :             FE E2 A3 2C D1 23 84 AA 98 C0 9B 66 18 9A 68 47
 :             E9
 358    3:           INTEGER 65537
 :           }
 :         }
 :       }
 */
function _readSubjectPublicKeyInfo(buffer, block) {
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    // algorithm identifier
    const algorithm = (0, asn1_1._readAlgorithmIdentifier)(buffer, inner_blocks[0]);
    //const parameters         = _readBitString(buffer,inner_blocks[1]);
    const subjectPublicKey = (0, asn1_1._readBitString)(buffer, inner_blocks[1]);
    // read the 2 big integers of the key
    const data = subjectPublicKey.data;
    const values = (0, asn1_1._readListOfInteger)(data);
    // xx const value = _readListOfInteger(data);
    return {
        algorithm: algorithm.identifier,
        keyLength: (values[0].length - 1),
        subjectPublicKey: _readSubjectPublicKey(subjectPublicKey.data),
        //xx values: values,
        //xx values_length : values.map(function (a){ return a.length; })
    };
}
function _readSubjectECCPublicKeyInfo(buffer, block) {
    const inner_blocks = (0, asn1_1._readStruct)(buffer, block);
    // first parameter is the second element of the first block, which is why we have another algorithm
    const algorithm = (0, asn1_1._readECCAlgorithmIdentifier)(buffer, inner_blocks[0]);
    // the public key is already in bit format, we just need to read it
    const subjectPublicKey = (0, asn1_1._readBitString)(buffer, inner_blocks[1]);
    // take out the data which is the entirity of our public key 
    const data = subjectPublicKey.data;
    return {
        algorithm: algorithm.identifier,
        keyLength: (data.length - 1),
        subjectPublicKey: {
            modulus: data
        }
    };
}
function readTbsCertificate(buffer, block) {
    const blocks = (0, asn1_1._readStruct)(buffer, block);
    let version, serialNumber, signature, issuer, validity, subject, subjectFingerPrint, extensions;
    let subjectPublicKeyInfo;
    if (blocks.length === 6) {
        // X509 Version 1:
        version = 1;
        serialNumber = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._readLongIntegerValue)(buffer, blocks[0]));
        signature = (0, asn1_1._readAlgorithmIdentifier)(buffer, blocks[1]);
        issuer = _readName(buffer, blocks[2]);
        validity = _readValidity(buffer, blocks[3]);
        subject = _readName(buffer, blocks[4]);
        subjectFingerPrint = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, crypto_utils_1.makeSHA1Thumbprint)((0, asn1_1._getBlock)(buffer, blocks[4])));
        subjectPublicKeyInfo = _readSubjectPublicKeyInfo(buffer, blocks[5]);
        extensions = null;
    }
    else {
        // X509 Version 3:
        const version_block = (0, asn1_1._findBlockAtIndex)(blocks, 0);
        if (!version_block) {
            throw new Error("cannot find version block");
        }
        version = (0, asn1_1._readVersionValue)(buffer, version_block) + 1;
        serialNumber = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._readLongIntegerValue)(buffer, blocks[1]));
        signature = (0, asn1_1._readAlgorithmIdentifier)(buffer, blocks[2]);
        issuer = _readName(buffer, blocks[3]);
        validity = _readValidity(buffer, blocks[4]);
        subject = _readName(buffer, blocks[5]);
        subjectFingerPrint = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, crypto_utils_1.makeSHA1Thumbprint)((0, asn1_1._getBlock)(buffer, blocks[5])));
        const inner_block = (0, asn1_1._readStruct)(buffer, blocks[6]);
        const what_type = (0, asn1_1._readAlgorithmIdentifier)(buffer, inner_block[0]).identifier;
        switch (what_type) {
            case "rsaEncryption": {
                subjectPublicKeyInfo = _readSubjectPublicKeyInfo(buffer, blocks[6]);
                break;
            }
            case "ecPublicKey":
            default: {
                subjectPublicKeyInfo = _readSubjectECCPublicKeyInfo(buffer, blocks[6]);
                break;
            }
        }
        const extensionBlock = (0, asn1_1._findBlockAtIndex)(blocks, 3);
        if (!extensionBlock) {
            // tslint:disable-next-line: no-console
            console.log("X509 certificate is invalid : cannot find extension block version =" + version_block);
            extensions = null;
        }
        else {
            extensions = _readExtensions(buffer, extensionBlock);
        }
    }
    return {
        version,
        serialNumber,
        signature,
        issuer,
        validity,
        subject,
        subjectFingerPrint,
        subjectPublicKeyInfo,
        extensions,
    };
}
exports.readTbsCertificate = readTbsCertificate;
/**
 * explore a certificate structure
 * @param certificate
 * @returns a json object that exhibits the internal data of the certificate
 */
function exploreCertificate(certificate) {
    assert(certificate instanceof Buffer);
    if (!certificate._exploreCertificate_cache) {
        const block_info = (0, asn1_1.readTag)(certificate, 0);
        const blocks = (0, asn1_1._readStruct)(certificate, block_info);
        certificate._exploreCertificate_cache = {
            tbsCertificate: readTbsCertificate(certificate, blocks[0]),
            signatureAlgorithm: (0, asn1_1._readAlgorithmIdentifier)(certificate, blocks[1]),
            signatureValue: (0, asn1_1._readSignatureValue)(certificate, blocks[2]),
        };
    }
    return certificate._exploreCertificate_cache;
}
exports.exploreCertificate = exploreCertificate;
/**
 * @method split_der
 * split a multi chain certificates
 * @param certificateChain  the certificate chain in der (binary) format}
 * @returns an array of Der , each element of the array is one certificate of the chain
 */
function split_der(certificateChain) {
    const certificate_chain = [];
    do {
        const block_info = (0, asn1_1.readTag)(certificateChain, 0);
        const length = block_info.position + block_info.length;
        const der_certificate = certificateChain.slice(0, length);
        certificate_chain.push(der_certificate);
        certificateChain = certificateChain.slice(length);
    } while (certificateChain.length > 0);
    return certificate_chain;
}
exports.split_der = split_der;
/**
 * @method combine_der
 * combine an array of certificates into a single blob
 * @param certificates a array with the individual DER certificates of the chain
 * @return a concatenated buffer containing the certificates
 */
function combine_der(certificates) {
    // perform some sanity check
    for (const cert of certificates) {
        const b = split_der(cert);
        let sum = 0;
        b.forEach((block) => {
            const block_info = (0, asn1_1.readTag)(block, 0);
            //xx console.log("xxxx" ,cert.length,block_info);
            //xx console.log(cert.toString("base64"));
            assert(block_info.position + block_info.length === block.length);
            sum += block.length;
        });
        assert(sum === cert.length);
    }
    return Buffer.concat(certificates);
}
exports.combine_der = combine_der;
//# sourceMappingURL=crypto_explore_certificate.js.map