/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/**
 * @module node-opcua-transport
 */
import { EventEmitter } from "events";
import { Socket } from "net";
import { ErrorCallback, CallbackWithData, StatusCode } from "node-opcua-status-code";
export interface MockSocket {
    invalid?: boolean;
    [key: string]: any;
    destroy(): void;
    end(): void;
}
export declare function setFakeTransport(mockSocket: MockSocket): void;
export declare function getFakeTransport(): any;
export interface TCP_transport {
    /**
     * notify the observers that a message chunk has been received
     * @event chunk
     * @param message_chunk the message chunk
     */
    on(eventName: "chunk", eventHandler: (messageChunk: Buffer) => void): this;
    /**
     * notify the observers that the transport layer has been disconnected.
     * @event socket_closed
     * @param err the Error object or null
     */
    on(eventName: "socket_closed", eventHandler: (err: Error | null) => void): this;
    /**
     * notify the observers that the transport layer has been disconnected.
     * @event close
     */
    on(eventName: "close", eventHandler: (err: Error | null) => void): this;
    once(eventName: "chunk", eventHandler: (messageChunk: Buffer) => void): this;
    once(eventName: "socket_closed", eventHandler: (err: Error | null) => void): this;
    once(eventName: "close", eventHandler: (err: Error | null) => void): this;
    emit(eventName: "socket_closed", err?: Error | null): boolean;
    emit(eventName: "close", err?: Error | null): boolean;
    emit(eventName: "chunk", messageChunk: Buffer): boolean;
}
export declare class TCP_transport extends EventEmitter {
    private static registry;
    /**
     * indicates the version number of the OPCUA protocol used
     * @default  0
     */
    protocolVersion: number;
    maxMessageSize: number;
    maxChunkCount: number;
    sendBufferSize: number;
    receiveBufferSize: number;
    bytesWritten: number;
    bytesRead: number;
    chunkWrittenCount: number;
    chunkReadCount: number;
    name: string;
    _socket: Socket | null;
    /**
     * the size of the header in bytes
     * @default  8
     */
    private readonly headerSize;
    private _disconnecting;
    private _timerId;
    private _onSocketClosedHasBeenCalled;
    private _onSocketEndedHasBeenCalled;
    private _theCallback?;
    private _on_error_during_one_time_message_receiver;
    private packetAssembler?;
    private _timeout;
    constructor();
    setLimits({ receiveBufferSize, sendBufferSize, maxMessageSize, maxChunkCount }: {
        receiveBufferSize: number;
        sendBufferSize: number;
        maxMessageSize: number;
        maxChunkCount: number;
    }): void;
    get timeout(): number;
    set timeout(value: number);
    dispose(): void;
    /**
     * write the message_chunk on the socket.
     * @method write
     * @param messageChunk
     */
    write(messageChunk: Buffer, callback?: (err?: Error) => void | undefined): void;
    get isDisconnecting(): boolean;
    /**
     * disconnect the TCP layer and close the underlying socket.
     * The ```"close"``` event will be emitted to the observers with err=null.
     *
     * @method disconnect
     * @async
     * @param callback
     */
    disconnect(callback: ErrorCallback): void;
    isValid(): boolean;
    protected _write_chunk(messageChunk: Buffer, callback?: (err?: Error) => void | undefined): void;
    protected on_socket_ended(err: Error | null): void;
    protected _install_packetAssembler(): void;
    /**
     * @method _install_socket
     * @param socket {Socket}
     * @protected
     */
    protected _install_socket(socket: Socket): void;
    sendErrorMessage(statusCode: StatusCode, extraErrorDescription: string | null): void;
    prematureTerminate(err: Error, statusCode: StatusCode): void;
    /**
     * @method _install_one_time_message_receiver
     *
     * install a one time message receiver callback
     *
     * Rules:
     * * TCP_transport will not emit the ```message``` event, while the "one time message receiver" is in operation.
     * * the TCP_transport will wait for the next complete message chunk and call the provided callback func
     *   ```callback(null,messageChunk);```
     *
     * if a messageChunk is not received within ```TCP_transport.timeout``` or if the underlying socket reports
     * an error, the callback function will be called with an Error.
     *
     */
    protected _install_one_time_message_receiver(callback: CallbackWithData): void;
    private _fulfill_pending_promises;
    private _on_message_chunk_received;
    private _cleanup_timers;
    private _start_one_time_message_receiver;
    private on_socket_closed;
    private _on_socket_data;
    private _on_socket_close;
    private _on_socket_ended_message;
    private _on_socket_end;
    private _on_socket_error;
}
