"use strict";
/**
 * @module node-opcua-secure-channel
 */
// tslint:disable:max-line-length
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageChunker = void 0;
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_basic_types_1 = require("node-opcua-basic-types");
const node_opcua_binary_stream_1 = require("node-opcua-binary-stream");
const node_opcua_service_secure_channel_1 = require("node-opcua-service-secure-channel");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_chunkmanager_1 = require("node-opcua-chunkmanager");
const secure_message_chunk_manager_1 = require("./secure_message_chunk_manager");
const sequence_number_generator_1 = require("./sequence_number_generator");
const doTraceChunk = process.env.NODEOPCUADEBUG && process.env.NODEOPCUADEBUG.indexOf("CHUNK") >= 0;
const errorLog = (0, node_opcua_debug_1.make_errorLog)("secure_channel");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("secure_channel");
/**
 * @class MessageChunker
 * @param options {Object}
 * @param options.securityHeader  {Object} SecurityHeader
 * @param [options.derivedKeys] {Object} derivedKeys
 * @constructor
 */
class MessageChunker {
    constructor(options) {
        options = options || {};
        this.sequenceNumberGenerator = new sequence_number_generator_1.SequenceNumberGenerator();
        this.maxMessageSize = options.maxMessageSize || MessageChunker.defaultMaxMessageSize;
        this.maxChunkCount = options.maxChunkCount === undefined ? MessageChunker.defaultChunkCount : options.maxChunkCount;
        this.update(options);
    }
    dispose() {
        this.securityHeader = null;
        this.derivedKeys = undefined;
        this._stream = undefined;
    }
    /***
     * update security information
     */
    update(options) {
        options = options || {};
        options.securityHeader =
            options.securityHeader ||
                new node_opcua_service_secure_channel_1.AsymmetricAlgorithmSecurityHeader({
                    securityPolicyUri: "http://opcfoundation.org/UA/SecurityPolicy#None"
                });
        (0, node_opcua_assert_1.assert)(options !== null && typeof options === "object");
        (0, node_opcua_assert_1.assert)(options.securityHeader !== null && typeof options.securityHeader === "object");
        this.securityHeader = options.securityHeader;
        this.derivedKeys = options.derivedKeys || undefined;
    }
    chunkSecureMessage(msgType, options, message, messageChunkCallback) {
        (0, node_opcua_assert_1.assert)(typeof messageChunkCallback === "function");
        const makeAbandonChunk = () => {
            const finalC = "A";
            const msgType = "MSG";
            const buffer = Buffer.alloc(
            // MSGA
            4 +
                // length
                4 +
                // secureChannelId
                4 +
                // tokenId
                4 +
                2 * 4);
            const stream = new node_opcua_binary_stream_1.BinaryStream(buffer);
            // message header --------------------------
            // ---------------------------------------------------------------
            // OPC UA Secure Conversation Message Header : Part 6 page 36
            // MessageType     Byte[3]
            // IsFinal         Byte[1]  C : intermediate, F: Final , A: Final with Error
            // MessageSize     UInt32   The length of the MessageChunk, in bytes. This value includes size of the message header.
            // SecureChannelId UInt32   A unique identifier for the ClientSecureChannelLayer assigned by the server.
            stream.writeUInt8(msgType.charCodeAt(0));
            stream.writeUInt8(msgType.charCodeAt(1));
            stream.writeUInt8(msgType.charCodeAt(2));
            stream.writeUInt8(finalC.charCodeAt(0));
            stream.writeUInt32(0); // will be written later
            stream.writeUInt32(options.channelId || 0); // secure channel id
            const securityHeader = new node_opcua_service_secure_channel_1.SymmetricAlgorithmSecurityHeader({
                tokenId: options.tokenId
            });
            securityHeader.encode(stream);
            const sequenceHeader = new node_opcua_chunkmanager_1.SequenceHeader({
                sequenceNumber: this.sequenceNumberGenerator.next(),
                requestId: options.requestId /// fix me
            });
            sequenceHeader.encode(stream);
            // write chunk length
            const length = stream.length;
            stream.length = 4;
            stream.writeUInt32(length);
            stream.length = length;
            return buffer;
        };
        // calculate message size ( with its  encodingDefaultBinary)
        const binSize = message.binaryStoreSize() + 4;
        const stream = new node_opcua_binary_stream_1.BinaryStream(binSize);
        this._stream = stream;
        (0, node_opcua_basic_types_1.encodeExpandedNodeId)(message.schema.encodingDefaultBinary, stream);
        message.encode(stream);
        let securityHeader;
        if (msgType === "OPN") {
            securityHeader = this.securityHeader;
        }
        else {
            securityHeader = new node_opcua_service_secure_channel_1.SymmetricAlgorithmSecurityHeader({ tokenId: options.tokenId });
        }
        const chunkManager = new secure_message_chunk_manager_1.SecureMessageChunkManager(msgType, options, securityHeader || null, this.sequenceNumberGenerator);
        const { chunkCount, totalLength } = chunkManager.evaluateTotalLengthAndChunks(stream.buffer.length);
        if (this.maxChunkCount > 0 && chunkCount > this.maxChunkCount) {
            errorLog(`[NODE-OPCUA-E10] message chunkCount ${chunkCount} exceeds the negotiated maximum chunk count ${this.maxChunkCount}, message current size is ${totalLength}`);
            return messageChunkCallback(new Error("message chunkCount exceeds the negotiated maximum message count"), makeAbandonChunk());
        }
        if (this.maxMessageSize > 0 && totalLength > this.maxMessageSize) {
            errorLog(`[NODE-OPCUA-E11] message size ${totalLength} exceeds the negotiated message size ${this.maxMessageSize} nb chunks ${chunkCount}`);
            return messageChunkCallback(new Error("message size exceeds the negotiated message size"), makeAbandonChunk());
        }
        let nbChunks = 0;
        let totalSize = 0;
        chunkManager
            .on("chunk", (messageChunk) => {
            nbChunks++;
            totalSize += messageChunk.length;
            if (this.maxChunkCount && nbChunks > this.maxChunkCount) {
                errorLog(`[NODE-OPCUA-E09] message chunkCount ${nbChunks} exceeds the negotiated maximum message count ${this.maxChunkCount}, message current size is ${totalSize}`);
            }
            messageChunkCallback(null, messageChunk);
        })
            .on("finished", () => {
            if (doTraceChunk) {
                console.log((0, node_opcua_utils_1.timestamp)(), "   <$$ ", msgType, "nbChunk = " + nbChunks.toString().padStart(3), "totalLength = " + totalSize.toString().padStart(8), "l=", binSize.toString().padStart(6));
            }
            if (this.maxMessageSize !== 0 && totalSize > this.maxMessageSize) {
                // https://reference.opcfoundation.org/v105/Core/docs/Part6/7.1.2/#7.1.2.4
                // MaxMessageSize	UInt32	   The maximum size for any request Message.    
                //                             If a request Message exceeds this value the Client shall report a Bad_ResponseTooLarge *
                //                             error to the application. If MessageChunks have already been sent the Client shall also abort 
                //                             The Message size is calculated using the unencrypted Message body.
                //                             A value of zero indicates that the Server has no limit.
                errorLog(`[NODE-OPCUA-E07] message size ${totalSize} exceeds the negotiated message size ${this.maxMessageSize} nb chunks ${nbChunks}`);
            }
            messageChunkCallback(null, null);
        });
        chunkManager.write(stream.buffer, stream.buffer.length);
        chunkManager.end();
    }
}
exports.MessageChunker = MessageChunker;
MessageChunker.defaultMaxMessageSize = 16 * 1024 * 1024;
MessageChunker.defaultChunkCount = 0; // 0 => no limits
//# sourceMappingURL=message_chunker.js.map