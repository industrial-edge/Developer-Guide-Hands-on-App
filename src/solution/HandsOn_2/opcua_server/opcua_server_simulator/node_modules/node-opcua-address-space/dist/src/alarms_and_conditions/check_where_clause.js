"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkWhereClause = exports.__checkWhereClause = void 0;
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const session_context_1 = require("../../source/session_context");
const extract_event_fields_1 = require("./extract_event_fields");
function checkNot(addressSpace, sessionContext, whereClause, eventData, filteredOperands) {
    if (filteredOperands[0] instanceof node_opcua_types_1.ElementOperand) {
        const index = filteredOperands[0].index;
        return !__checkWhereClause(addressSpace, sessionContext, whereClause, index, eventData);
    }
    return false;
}
function checkOfType(addressSpace, ofType, eventData) {
    var _a;
    // istanbul ignore next
    if (!ofType) {
        throw new Error("invalid operand");
    }
    // istanbul ignore next
    if (ofType.value.dataType !== node_opcua_variant_1.DataType.NodeId) {
        throw new Error("invalid operand type (expecting Nodeid");
    }
    const ofTypeNode = addressSpace.findNode(ofType.value.value);
    // istanbul ignore next
    if (!ofTypeNode) {
        return false; // the ofType node is not known, we don't know what to do
    }
    // istanbul ignore next
    if (ofTypeNode.nodeClass !== node_opcua_data_model_1.NodeClass.ObjectType) {
        throw new Error("operand should be a ObjectType " + ofTypeNode.nodeId.toString());
    }
    const node = eventData.$eventDataSource;
    if (!node) {
        throw new Error("cannot find  node " + ((_a = eventData.$eventDataSource) === null || _a === void 0 ? void 0 : _a.toString()));
    }
    if (node.nodeClass === node_opcua_data_model_1.NodeClass.ObjectType) {
        return node.isSupertypeOf(ofTypeNode);
    }
    if (node.nodeClass === node_opcua_data_model_1.NodeClass.Object && node.typeDefinitionObj) {
        return node.typeDefinitionObj.isSupertypeOf(ofTypeNode);
    }
    return true;
}
function _extractValue(operand, eventData) {
    // eventData.readValue;
    const v = (0, extract_event_fields_1.extractEventFields)(session_context_1.SessionContext.defaultContext, [operand], eventData)[0];
    return v.value;
}
function checkInList(addressSpace, filterOperands, eventData) {
    const operand0 = filterOperands[0];
    if (!(operand0 instanceof node_opcua_types_1.SimpleAttributeOperand)) {
        // unsupported case
        return false;
    }
    const nodeId = _extractValue(operand0, eventData);
    if (!nodeId) {
        return false;
    }
    function _is(nodeId1, operandX) {
        const operandNode = addressSpace.findNode(operandX.value.value);
        if (!operandNode) {
            return false;
        }
        return (0, node_opcua_nodeid_1.sameNodeId)(nodeId1, operandNode.nodeId);
    }
    for (let i = 1; i < filterOperands.length; i++) {
        const filterOperand = filterOperands[i];
        if (filterOperand instanceof node_opcua_types_1.LiteralOperand && _is(nodeId, filterOperand)) {
            return true;
        }
    }
    return false;
}
function __checkWhereClause(addressSpace, sessionContext, whereClause, index, eventData) {
    if (!whereClause.elements || whereClause.elements.length === 0) {
        return true;
    }
    const element = whereClause.elements[index];
    if (!element) {
        return true;
    }
    switch (element.filterOperator) {
        case node_opcua_types_1.FilterOperator.Not:
            return checkNot(addressSpace, sessionContext, whereClause, eventData, element.filterOperands);
        case node_opcua_types_1.FilterOperator.OfType:
            return checkOfType(addressSpace, element.filterOperands[0], eventData);
        case node_opcua_types_1.FilterOperator.InList:
            return checkInList(addressSpace, element.filterOperands, eventData);
        default:
            // from Spec  OPC Unified Architecture, Part 4 133 Release 1.04
            //  Any basic FilterOperator in Table 119 may be used in the whereClause, however, only the
            //  OfType_14 FilterOperator from Table 120 is permitted.
            // tslint:disable-next-line: no-console
            console.log("whereClause = ", whereClause.toString());
            throw new Error("Only OfType operator are allowed in checkWhereClause");
    }
}
exports.__checkWhereClause = __checkWhereClause;
function checkWhereClause(addressSpace, sessionContext, whereClause, eventData) {
    if (!whereClause.elements || whereClause.elements.length === 0) {
        return true;
    }
    return __checkWhereClause(addressSpace, sessionContext, whereClause, 0, eventData);
}
exports.checkWhereClause = checkWhereClause;
//# sourceMappingURL=check_where_clause.js.map