"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeCrawlerBase = void 0;
/**
 * @module node-opcua-client-crawler
 */
const events_1 = require("events");
const async = require("async");
const underscore_1 = require("underscore");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_constants_1 = require("node-opcua-constants");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_service_browse_1 = require("node-opcua-service-browse");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const cache_node_1 = require("./cache_node");
const private_1 = require("./private");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
//                         "ReferenceType | IsForward | BrowseName | NodeClass | DisplayName | TypeDefinition"
const resultMask = (0, node_opcua_data_model_1.makeResultMask)("ReferenceType | IsForward | BrowseName | DisplayName | NodeClass | TypeDefinition");
function make_node_attribute_key(nodeId, attributeId) {
    return nodeId.toString() + "_" + node_opcua_data_model_1.AttributeIds[attributeId];
}
function convertToStandardArray(a) {
    if (a === undefined || a === null) {
        return undefined;
    }
    if (a instanceof Array) {
        return a;
    }
    if (a instanceof Buffer) {
        return a;
    }
    try {
        const b = [];
        for (const x of a) {
            b.push(x);
        }
        return b;
    }
    catch (err) {
        warningLog(a);
        warningLog("convertToStandardArray error", err.message);
        return a;
    }
}
//
// some server do not expose the ReferenceType Node in their address space
// ReferenceType are defined by the OPCUA standard and can be pre-populated in the crawler.
// Pre-populating the ReferenceType node in the crawler will also reduce the network traffic.
//
/*=
 *
 * @param arr
 * @param maxNode
 * @private
 * @return {*}
 */
function _fetch_elements(arr, maxNode) {
    (0, node_opcua_assert_1.assert)(Array.isArray(arr));
    (0, node_opcua_assert_1.assert)(arr.length > 0);
    const highLimit = maxNode <= 0 ? arr.length : maxNode;
    const tmp = arr.splice(0, highLimit);
    (0, node_opcua_assert_1.assert)(tmp.length > 0);
    return tmp;
}
const referencesNodeId = (0, node_opcua_nodeid_1.resolveNodeId)("References");
// const hierarchicalReferencesId = resolveNodeId("HierarchicalReferences");
const hasTypeDefinitionNodeId = (0, node_opcua_nodeid_1.resolveNodeId)("HasTypeDefinition");
function _setExtraReference(task, callback) {
    const param = task.param;
    (0, node_opcua_assert_1.assert)(param.userData.setExtraReference);
    param.userData.setExtraReference(param.parentNode, param.reference, param.childCacheNode, param.userData);
    callback();
}
function getReferenceTypeId(referenceType) {
    if (!referenceType) {
        return null;
    }
    /* istanbul ignore next */
    if (referenceType.toString() === "i=45" || referenceType === "HasSubtype") {
        return node_opcua_nodeid_1.NodeId.resolveNodeId("i=45");
    }
    else if (referenceType.toString() === "i=35" || referenceType === "Organizes") {
        return node_opcua_nodeid_1.NodeId.resolveNodeId("i=35");
    }
    else if (referenceType.toString() === "i=47" || referenceType === "HasComponent") {
        return node_opcua_nodeid_1.NodeId.resolveNodeId("i=47");
    }
    else if (referenceType.toString() === "i=46" || referenceType === "HasProperty") {
        return node_opcua_nodeid_1.NodeId.resolveNodeId("i=46");
    }
    else if (referenceType.toString() === node_opcua_nodeid_1.NodeId.resolveNodeId("HasEncoding").toString() || referenceType === "HasEncoding") {
        return node_opcua_nodeid_1.NodeId.resolveNodeId("HasEncoding");
    }
    else if (referenceType.toString() === node_opcua_nodeid_1.NodeId.resolveNodeId("HasDescription").toString() ||
        referenceType === "HasDescription") {
        return node_opcua_nodeid_1.NodeId.resolveNodeId("HasDescription");
    }
    else {
        throw new Error("Invalid reference Type" + referenceType.toString());
    }
}
// tslint:disable:max-classes-per-file
/**
 * @class NodeCrawlerBase
 * @param session
 * @constructor
 */
class NodeCrawlerBase extends events_1.EventEmitter {
    constructor(session) {
        super();
        this.maxNodesPerRead = 0;
        this.maxNodesPerBrowse = 0;
        this.startTime = new Date();
        this.readCounter = 0;
        this.browseCounter = 0;
        this.browseNextCounter = 0;
        this.transactionCounter = 0;
        this._prePopulatedSet = new WeakSet();
        this.session = session;
        // verify that session object provides the expected methods (browse/read)
        (0, node_opcua_assert_1.assert)(typeof session.browse === "function");
        (0, node_opcua_assert_1.assert)(typeof session.read === "function");
        this.browseNameMap = {};
        this._objectCache = {};
        this._objMap = {};
        this._crawled = new Set();
        this._visitedNode = new Set();
        this._initialize_referenceTypeId();
        this.pendingReadTasks = [];
        this.pendingBrowseTasks = [];
        this.pendingBrowseNextTasks = [];
        this.taskQueue = async.queue((task, callback) => {
            // use process next tick to relax the stack frame
            /* istanbul ignore next */
            if (doDebug) {
                debugLog(" executing Task ", task.name); // JSON.stringify(task, null, " "));
            }
            setImmediate(() => {
                task.func.call(this, task, () => {
                    this.resolve_deferred_browseNext();
                    this.resolve_deferred_browseNode();
                    this.resolve_deferred_readNode();
                    callback();
                });
            });
        }, 1);
        // MaxNodesPerRead from Server.ServerCapabilities.OperationLimits
        // VariableIds.ServerType_ServerCapabilities_OperationLimits_MaxNodesPerRead
        this.maxNodesPerRead = 0;
        //  MaxNodesPerBrowse from Server.ServerCapabilities.OperationLimits
        //  VariableIds.Server_ServerCapabilities_OperationLimits_MaxNodesPerBrowse
        this.maxNodesPerBrowse = 0; // 0 = no limits
        // statistics
        this.startTime = new Date();
        this.readCounter = 0;
        this.browseCounter = 0;
        this.transactionCounter = 0;
    }
    static follow(crawler, cacheNode, userData, referenceType, browseDirection) {
        const referenceTypeNodeId = getReferenceTypeId(referenceType);
        for (const reference of cacheNode.references) {
            if (browseDirection === node_opcua_data_model_1.BrowseDirection.Forward && !reference.isForward) {
                continue;
            }
            if (browseDirection === node_opcua_data_model_1.BrowseDirection.Inverse && reference.isForward) {
                continue;
            }
            if (!referenceTypeNodeId) {
                crawler.followReference(cacheNode, reference, userData);
            }
            else {
                if (node_opcua_nodeid_1.NodeId.sameNodeId(referenceTypeNodeId, reference.referenceTypeId)) {
                    crawler.followReference(cacheNode, reference, userData);
                }
            }
        }
    }
    dispose() {
        (0, node_opcua_assert_1.assert)(this.pendingReadTasks.length === 0);
        (0, node_opcua_assert_1.assert)(this.pendingBrowseTasks.length === 0);
        (0, node_opcua_assert_1.assert)(this.pendingBrowseNextTasks.length === 0);
        this.pendingReadTasks.length = 0;
        this.pendingBrowseTasks.length = 0;
        this.pendingBrowseNextTasks.length = 0;
        (0, node_opcua_assert_1.assert)(this.taskQueue.length() === 0);
        Object.values(this._objectCache).map((cache) => cache.dispose());
        Object.values(this._objMap).map((obj) => {
            Object.keys(obj).map((k) => (obj[k] = undefined));
        });
        this.taskQueue.kill();
        this.session = null;
        this.browseNameMap = null;
        this.taskQueue = null;
        this._objectCache = {};
        this._objMap = null;
        this._crawled = null;
        this._visitedNode = null;
        this._prePopulatedSet = null;
    }
    toString() {
        return ("" +
            `reads:       ${this.readCounter}\n` +
            `browses:     ${this.browseCounter}  \n` +
            `transaction: ${this.transactionCounter}  \n`);
    }
    crawl(nodeId, userData, ...args) {
        const endCallback = args[0];
        (0, node_opcua_assert_1.assert)(typeof endCallback === 'function', "expecting callback");
        nodeId = (0, node_opcua_nodeid_1.resolveNodeId)(nodeId);
        (0, node_opcua_assert_1.assert)(typeof endCallback === "function");
        this._readOperationalLimits((err) => {
            /* istanbul ignore next */
            if (err) {
                return endCallback(err);
            }
            this._inner_crawl(nodeId, userData, endCallback);
        });
    }
    /**
     * @internal
     * @private
     */
    _inner_crawl(nodeId, userData, endCallback) {
        (0, node_opcua_assert_1.assert)(userData !== null && typeof userData === "object");
        (0, node_opcua_assert_1.assert)(typeof endCallback === "function");
        let hasEnded = false;
        this.taskQueue.drain(() => {
            debugLog("taskQueue is empty !!", this.taskQueue.length());
            if (!hasEnded) {
                hasEnded = true;
                this._visitedNode = new Set();
                this._crawled = new Set();
                this.emit("end");
                endCallback();
            }
        });
        let cacheNode = this._getCacheNode(nodeId);
        if (!cacheNode) {
            cacheNode = this._createCacheNode(nodeId);
        }
        (0, node_opcua_assert_1.assert)(cacheNode.nodeId.toString() === nodeId.toString());
        // ----------------------- Read missing essential information about node
        // such as nodeClass, typeDefinition browseName, displayName
        // this sequence is only necessary on the top node being crawled,
        // as browseName,displayName,nodeClass will be provided by ReferenceDescription later on for child nodes
        //
        async.parallel({
            task1: (callback) => {
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.BrowseName, (err, value) => {
                    /* istanbul ignore else */
                    if (err) {
                        return callback(err);
                    }
                    (0, node_opcua_assert_1.assert)(value instanceof node_opcua_data_model_1.QualifiedName);
                    cacheNode.browseName = value;
                    setImmediate(callback);
                });
            },
            task2: (callback) => {
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.NodeClass, (err, value) => {
                    /* istanbul ignore else */
                    if (err) {
                        return callback(err);
                    }
                    cacheNode.nodeClass = value;
                    setImmediate(callback);
                });
            },
            task3: (callback) => {
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.DisplayName, (err, value) => {
                    /* istanbul ignore else */
                    if (err) {
                        return callback(err);
                    }
                    (0, node_opcua_assert_1.assert)(value instanceof node_opcua_data_model_1.LocalizedText);
                    cacheNode.displayName = value;
                    setImmediate(callback);
                });
            },
            task4: (callback) => {
                this._resolve_deferred_readNode(callback);
            }
        }, (err, data) => {
            this._add_crawl_task(cacheNode, userData);
        });
    }
    _add_crawl_task(cacheNode, userData) {
        (0, node_opcua_assert_1.assert)(userData);
        (0, node_opcua_assert_1.assert)(this !== null && typeof this === "object");
        const key = cacheNode.nodeId.toString();
        /* istanbul ignore else */
        if (this._crawled.has(key)) {
            return;
        }
        this._crawled.add(key);
        const task = {
            func: NodeCrawlerBase.prototype._crawl_task,
            param: {
                cacheNode,
                userData
            }
        };
        this._push_task("_crawl task", task);
    }
    followReference(parentNode, reference, userData) {
        (0, node_opcua_assert_1.assert)(reference instanceof node_opcua_service_browse_1.ReferenceDescription);
        let referenceTypeIdCacheNode = this._getCacheNode(reference.referenceTypeId);
        if (this._prePopulatedSet.has(referenceTypeIdCacheNode)) {
            this._prePopulatedSet.delete(referenceTypeIdCacheNode);
            this._add_crawl_task(referenceTypeIdCacheNode, userData);
        }
        if (!referenceTypeIdCacheNode) {
            referenceTypeIdCacheNode = this._createCacheNode(reference.referenceTypeId);
            referenceTypeIdCacheNode.nodeClass = node_opcua_data_model_1.NodeClass.ReferenceType;
            this._add_crawl_task(referenceTypeIdCacheNode, userData);
        }
        let childCacheNode = this._getCacheNode(reference.nodeId);
        if (!childCacheNode) {
            childCacheNode = this._createCacheNode(reference.nodeId, parentNode, reference);
            childCacheNode.browseName = reference.browseName;
            childCacheNode.displayName = reference.displayName;
            childCacheNode.typeDefinition = reference.typeDefinition;
            childCacheNode.nodeClass = reference.nodeClass;
            (0, node_opcua_assert_1.assert)(childCacheNode.parent === parentNode);
            (0, node_opcua_assert_1.assert)(childCacheNode.referenceToParent === reference);
            this._add_crawl_task(childCacheNode, userData);
        }
        else {
            if (userData.setExtraReference) {
                const task = {
                    func: _setExtraReference,
                    param: {
                        childCacheNode,
                        parentNode,
                        reference,
                        userData
                    }
                };
                this._push_task("setExtraRef", task);
            }
        }
    }
    /**
     * perform pending read Node operation
     * @method _resolve_deferred_readNode
     * @param callback
     * @private
     * @internal
     */
    _resolve_deferred_readNode(callback) {
        if (this.pendingReadTasks.length === 0) {
            // nothing to read
            callback();
            return;
        }
        debugLog("_resolve_deferred_readNode = ", this.pendingReadTasks.length);
        const selectedPendingReadTasks = _fetch_elements(this.pendingReadTasks, this.maxNodesPerRead);
        const nodesToRead = selectedPendingReadTasks.map((e) => e.nodeToRead);
        this.readCounter += nodesToRead.length;
        this.transactionCounter++;
        this.session.read(nodesToRead, (err, dataValues) => {
            /* istanbul ignore else */
            if (err) {
                return callback(err);
            }
            for (const pair of (0, underscore_1.zip)(selectedPendingReadTasks, dataValues)) {
                const readTask = pair[0];
                const dataValue = pair[1];
                (0, node_opcua_assert_1.assert)(Object.prototype.hasOwnProperty.call(dataValue, "statusCode"));
                if (dataValue.statusCode.equals(node_opcua_status_code_1.StatusCodes.Good)) {
                    /* istanbul ignore else */
                    if (dataValue.value === null) {
                        readTask.action(null, dataValue);
                    }
                    else {
                        readTask.action(dataValue.value.value, dataValue);
                    }
                }
                else {
                    readTask.action({ name: dataValue.statusCode.toString() }, dataValue);
                }
            }
            callback();
        });
    }
    _resolve_deferred_browseNode(callback) {
        if (this.pendingBrowseTasks.length === 0) {
            callback();
            return;
        }
        debugLog("_resolve_deferred_browseNode = ", this.pendingBrowseTasks.length);
        const objectsToBrowse = _fetch_elements(this.pendingBrowseTasks, this.maxNodesPerBrowse);
        const nodesToBrowse = objectsToBrowse.map((e) => {
            (0, node_opcua_assert_1.assert)(Object.prototype.hasOwnProperty.call(e, "referenceTypeId"));
            return new node_opcua_service_browse_1.BrowseDescription({
                browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
                includeSubtypes: true,
                nodeId: e.nodeId,
                referenceTypeId: e.referenceTypeId,
                resultMask
            });
        });
        this.browseCounter += nodesToBrowse.length;
        this.transactionCounter++;
        this.session.browse(nodesToBrowse, (err, browseResults) => {
            /* istanbul ignore else */
            if (err) {
                debugLog("session.browse err:", err);
                return callback(err || undefined);
            }
            (0, node_opcua_assert_1.assert)(browseResults.length === nodesToBrowse.length);
            browseResults = browseResults || [];
            const task = {
                func: NodeCrawlerBase.prototype._process_browse_response_task,
                param: {
                    browseResults,
                    objectsToBrowse
                }
            };
            this._unshift_task("process browseResults", task);
            callback();
        });
    }
    _resolve_deferred_browseNext(callback) {
        /* istanbul ignore else */
        if (this.pendingBrowseNextTasks.length === 0) {
            callback();
            return;
        }
        debugLog("_resolve_deferred_browseNext = ", this.pendingBrowseNextTasks.length);
        const objectsToBrowse = _fetch_elements(this.pendingBrowseNextTasks, this.maxNodesPerBrowse);
        const continuationPoints = objectsToBrowse.map((e) => e.continuationPoint);
        this.browseNextCounter += continuationPoints.length;
        this.transactionCounter++;
        this.session.browseNext(continuationPoints, false, (err, browseResults) => {
            if (err) {
                debugLog("session.browse err:", err);
                return callback(err || undefined);
            }
            (0, node_opcua_assert_1.assert)(browseResults.length === continuationPoints.length);
            browseResults = browseResults || [];
            const task = {
                func: NodeCrawlerBase.prototype._process_browse_response_task,
                param: {
                    browseResults,
                    objectsToBrowse
                }
            };
            this._unshift_task("process browseResults", task);
            callback();
        });
    }
    /**
     * @method _unshift_task
     * add a task on top of the queue (high priority)
     * @param name
     * @param task
     * @private
     */
    _unshift_task(name, task) {
        (0, node_opcua_assert_1.assert)(typeof task.func === "function");
        (0, node_opcua_assert_1.assert)(task.func.length === 2);
        this.taskQueue.unshift(task);
        debugLog("unshift task", name);
    }
    /**
     * @method _push_task
     * add a task at the bottom of the queue (low priority)
     * @param name
     * @param task
     * @private
     */
    _push_task(name, task) {
        (0, node_opcua_assert_1.assert)(typeof task.func === "function");
        (0, node_opcua_assert_1.assert)(task.func.length === 2);
        debugLog("pushing task", name);
        this.taskQueue.push(task);
    }
    /***
     * @method _emit_on_crawled
     * @param cacheNode
     * @param userData
     * @private
     */
    _emit_on_crawled(cacheNode, userData) {
        this.emit("browsed", cacheNode, userData);
    }
    _crawl_task(task, callback) {
        const cacheNode = task.param.cacheNode;
        const nodeId = task.param.cacheNode.nodeId;
        const key = nodeId.toString();
        if (this._visitedNode.has(key)) {
            debugLog("skipping already visited", key);
            callback();
            return; // already visited
        }
        // mark as visited to avoid infinite recursion
        this._visitedNode.add(key);
        const browseNodeAction = (err, cacheNode1) => {
            if (err || !cacheNode1) {
                return;
            }
            for (const reference of cacheNode1.references) {
                // those ones come for free
                if (!this.has_cache_NodeAttribute(reference.nodeId, node_opcua_data_model_1.AttributeIds.BrowseName)) {
                    this.set_cache_NodeAttribute(reference.nodeId, node_opcua_data_model_1.AttributeIds.BrowseName, reference.browseName);
                }
                if (!this.has_cache_NodeAttribute(reference.nodeId, node_opcua_data_model_1.AttributeIds.DisplayName)) {
                    this.set_cache_NodeAttribute(reference.nodeId, node_opcua_data_model_1.AttributeIds.DisplayName, reference.displayName);
                }
                if (!this.has_cache_NodeAttribute(reference.nodeId, node_opcua_data_model_1.AttributeIds.NodeClass)) {
                    this.set_cache_NodeAttribute(reference.nodeId, node_opcua_data_model_1.AttributeIds.NodeClass, reference.nodeClass);
                }
            }
            this._emit_on_crawled(cacheNode1, task.param.userData);
            const userData = task.param.userData;
            if (userData.onBrowse) {
                userData.onBrowse(this, cacheNode1, userData);
            }
        };
        this._defer_browse_node(cacheNode, referencesNodeId, browseNodeAction);
        callback();
    }
    _initialize_referenceTypeId() {
        const appendPrepopulatedReference = (browseName) => {
            const nodeId = (0, node_opcua_nodeid_1.makeNodeId)(node_opcua_constants_1.ReferenceTypeIds[browseName], 0);
            (0, node_opcua_assert_1.assert)(nodeId);
            const cacheNode = this._createCacheNode(nodeId);
            cacheNode.browseName = new node_opcua_data_model_1.QualifiedName({ name: browseName });
            cacheNode.nodeClass = node_opcua_data_model_1.NodeClass.ReferenceType;
            this._prePopulatedSet.add(cacheNode);
        };
        //  References
        //  +->(hasSubtype) NonHierarchicalReferences
        //                  +->(hasSubtype) HasTypeDefinition
        //  +->(hasSubtype) HierarchicalReferences
        //                  +->(hasSubtype) HasChild/ChildOf
        //                                  +->(hasSubtype) Aggregates/AggregatedBy
        //                                                  +-> HasProperty/PropertyOf
        //                                                  +-> HasComponent/ComponentOf
        //                                                  +-> HasHistoricalConfiguration/HistoricalConfigurationOf
        //                                 +->(hasSubtype) HasSubtype/HasSupertype
        //                  +->(hasSubtype) Organizes/OrganizedBy
        //                  +->(hasSubtype) HasEventSource/EventSourceOf
        appendPrepopulatedReference("HasSubtype");
        /* istanbul ignore else */
        if (false) {
            appendPrepopulatedReference("HasTypeDefinition");
            appendPrepopulatedReference("HasChild");
            appendPrepopulatedReference("HasProperty");
            appendPrepopulatedReference("HasComponent");
            appendPrepopulatedReference("HasHistoricalConfiguration");
            appendPrepopulatedReference("Organizes");
            appendPrepopulatedReference("HasEventSource");
            appendPrepopulatedReference("HasModellingRule");
            appendPrepopulatedReference("HasEncoding");
            appendPrepopulatedReference("HasDescription");
        }
    }
    _readOperationalLimits(callback) {
        const n1 = (0, node_opcua_nodeid_1.makeNodeId)(node_opcua_constants_1.VariableIds.Server_ServerCapabilities_OperationLimits_MaxNodesPerRead);
        const n2 = (0, node_opcua_nodeid_1.makeNodeId)(node_opcua_constants_1.VariableIds.Server_ServerCapabilities_OperationLimits_MaxNodesPerBrowse);
        const nodesToRead = [
            { nodeId: n1, attributeId: node_opcua_data_model_1.AttributeIds.Value },
            { nodeId: n2, attributeId: node_opcua_data_model_1.AttributeIds.Value }
        ];
        this.transactionCounter++;
        this.session.read(nodesToRead, (err, dataValues) => {
            /* istanbul ignore else */
            if (err) {
                return callback(err);
            }
            dataValues = dataValues;
            const fix = (self, maxNodePerX, dataValue) => {
                if (dataValue.statusCode.equals(node_opcua_status_code_1.StatusCodes.Good)) {
                    const value = dataValue.value.value;
                    // if this.maxNodesPerRead has been set (<>0) by the user before call is made,
                    // then it serve as a minimum
                    if (self[maxNodePerX]) {
                        if (value > 0) {
                            self[maxNodePerX] = Math.min(self[maxNodePerX], value);
                        }
                    }
                    else {
                        self[maxNodePerX] = value;
                    }
                }
                else {
                    debugLog("warning: server does not provide a valid dataValue for " + maxNodePerX, dataValue.statusCode.toString());
                }
                // ensure we have a sensible maxNodesPerRead value in case the server doesn't specify one
                self[maxNodePerX] = self[maxNodePerX] || 100;
                debugLog("maxNodesPerRead", self[maxNodePerX]);
            };
            fix(this, "maxNodesPerRead", dataValues[0]);
            fix(this, "maxNodesPerBrowse", dataValues[1]);
            callback();
        });
    }
    set_cache_NodeAttribute(nodeId, attributeId, value) {
        const key = make_node_attribute_key(nodeId, attributeId);
        this.browseNameMap[key] = value;
    }
    has_cache_NodeAttribute(nodeId, attributeId) {
        const key = make_node_attribute_key(nodeId, attributeId);
        return Object.prototype.hasOwnProperty.call(this.browseNameMap, key);
    }
    get_cache_NodeAttribute(nodeId, attributeId) {
        const key = make_node_attribute_key(nodeId, attributeId);
        return this.browseNameMap[key];
    }
    _defer_readNode(nodeId, attributeId, callback) {
        nodeId = (0, node_opcua_nodeid_1.resolveNodeId)(nodeId);
        const key = make_node_attribute_key(nodeId, attributeId);
        if (this.has_cache_NodeAttribute(nodeId, attributeId)) {
            callback(null, this.get_cache_NodeAttribute(nodeId, attributeId));
        }
        else {
            //   this.browseNameMap[key] = { "?": 1 };
            this.pendingReadTasks.push({
                action: (value, dataValue) => {
                    if (attributeId === node_opcua_data_model_1.AttributeIds.Value) {
                        this.set_cache_NodeAttribute(nodeId, attributeId, dataValue);
                        callback(null, dataValue);
                        return;
                    }
                    if (attributeId === node_opcua_data_model_1.AttributeIds.ArrayDimensions) {
                        value = dataValue.statusCode !== node_opcua_status_code_1.StatusCodes.Good ? null : value;
                        this.set_cache_NodeAttribute(nodeId, attributeId, value);
                        callback(null, value);
                        return;
                    }
                    if (dataValue.statusCode !== node_opcua_status_code_1.StatusCodes.Good) {
                        this.set_cache_NodeAttribute(nodeId, attributeId, dataValue);
                        callback(null, null);
                        return;
                    }
                    if (dataValue.statusCode === node_opcua_status_code_1.StatusCodes.Good) {
                        this.set_cache_NodeAttribute(nodeId, attributeId, value);
                        callback(null, value);
                    }
                    else {
                        callback(new Error("Error " +
                            dataValue.statusCode.toString() +
                            " while reading " +
                            nodeId.toString() +
                            " attributeIds " +
                            node_opcua_data_model_1.AttributeIds[attributeId]));
                    }
                },
                nodeToRead: {
                    attributeId,
                    nodeId
                }
            });
        }
    }
    _resolve_deferred(comment, collection, method) {
        debugLog("_resolve_deferred ", comment, collection.length);
        if (collection.length > 0) {
            this._push_task("adding operation " + comment, {
                func: (task, callback) => {
                    method.call(this, callback);
                },
                param: {}
            });
        }
    }
    resolve_deferred_readNode() {
        this._resolve_deferred("read_node", this.pendingReadTasks, this._resolve_deferred_readNode);
    }
    resolve_deferred_browseNode() {
        this._resolve_deferred("browse_node", this.pendingBrowseTasks, this._resolve_deferred_browseNode);
    }
    resolve_deferred_browseNext() {
        this._resolve_deferred("browse_next", this.pendingBrowseNextTasks, this._resolve_deferred_browseNext);
    }
    // ---------------------------------------------------------------------------------------
    _getCacheNode(nodeId) {
        const key = (0, node_opcua_nodeid_1.resolveNodeId)(nodeId).toString();
        return this._objectCache[key];
    }
    _createCacheNode(nodeId, parentNode, referenceToParent) {
        const key = (0, node_opcua_nodeid_1.resolveNodeId)(nodeId).toString();
        let cacheNode = this._objectCache[key];
        /* istanbul ignore else */
        if (cacheNode) {
            throw new Error("NodeCrawlerBase#_createCacheNode :" + " cache node should not exist already : " + nodeId.toString());
        }
        const nodeClass = (referenceToParent ? referenceToParent.nodeClass : node_opcua_data_model_1.NodeClass.Unspecified);
        switch (nodeClass) {
            case node_opcua_data_model_1.NodeClass.Method:
                cacheNode = new cache_node_1.CacheNode(nodeId);
                cacheNode.nodeClass = node_opcua_data_model_1.NodeClass.Method;
                break;
            case node_opcua_data_model_1.NodeClass.Object:
                cacheNode = new cache_node_1.CacheNode(nodeId);
                cacheNode.nodeClass = node_opcua_data_model_1.NodeClass.Object;
                break;
            case node_opcua_data_model_1.NodeClass.ObjectType:
                cacheNode = new cache_node_1.CacheNode(nodeId);
                cacheNode.nodeClass = node_opcua_data_model_1.NodeClass.ObjectType;
                break;
            case node_opcua_data_model_1.NodeClass.Variable:
                cacheNode = new cache_node_1.CacheNodeVariable(nodeId);
                break;
            case node_opcua_data_model_1.NodeClass.VariableType:
                cacheNode = new cache_node_1.CacheNodeVariableType(nodeId);
                break;
            default:
                cacheNode = new cache_node_1.CacheNode(nodeId);
                cacheNode.nodeClass = nodeClass;
                break;
        }
        cacheNode.parent = parentNode;
        cacheNode.referenceToParent = referenceToParent;
        (0, node_opcua_assert_1.assert)(!Object.prototype.hasOwnProperty.call(this._objectCache, key));
        this._objectCache[key] = cacheNode;
        return cacheNode;
    }
    /**
     * perform a deferred browse
     * instead of calling session.browse directly, this function add the request to a list
     * so that request can be grouped and send in one single browse command to the server.
     *
     * @method _defer_browse_node
     * @private
     *
     */
    _defer_browse_node(cacheNode, referenceTypeId, actionOnBrowse) {
        this.pendingBrowseTasks.push({
            action: (object) => {
                (0, node_opcua_assert_1.assert)(object === cacheNode);
                (0, node_opcua_assert_1.assert)(Array.isArray(object.references));
                (0, node_opcua_assert_1.assert)(cacheNode.browseName.name !== "pending");
                actionOnBrowse(null, cacheNode);
            },
            cacheNode,
            nodeId: cacheNode.nodeId,
            referenceTypeId
        });
    }
    _defer_browse_next(cacheNode, continuationPoint, referenceTypeId, actionOnBrowse) {
        this.pendingBrowseNextTasks.push({
            action: (object) => {
                (0, node_opcua_assert_1.assert)(object === cacheNode);
                (0, node_opcua_assert_1.assert)(Array.isArray(object.references));
                (0, node_opcua_assert_1.assert)(cacheNode.browseName.name !== "pending");
                actionOnBrowse(null, cacheNode);
            },
            cacheNode,
            continuationPoint,
            nodeId: cacheNode.nodeId,
            referenceTypeId
        });
    }
    /**
     * @method _process_single_browseResult
     * @param _objectToBrowse
     * @param browseResult
     * @private
     */
    _process_single_browseResult(_objectToBrowse, browseResult) {
        const cacheNode = _objectToBrowse.cacheNode;
        // note : some OPCUA may expose duplicated reference, they need to be filtered out
        // dedup reference
        cacheNode.references = cacheNode.references.concat(browseResult.references);
        if (browseResult.continuationPoint) {
            //
            this._defer_browse_next(_objectToBrowse.cacheNode, browseResult.continuationPoint, _objectToBrowse.referenceTypeId, (err, cacheNode1) => {
                this._process_single_browseResult2(_objectToBrowse);
            });
        }
        else {
            this._process_single_browseResult2(_objectToBrowse);
        }
    }
    _process_single_browseResult2(_objectToBrowse) {
        const cacheNode = _objectToBrowse.cacheNode;
        cacheNode.references = (0, private_1.dedup_reference)(cacheNode.references);
        // extract the reference containing HasTypeDefinition
        const tmp = cacheNode.references.filter((x) => (0, node_opcua_nodeid_1.sameNodeId)(x.referenceTypeId, hasTypeDefinitionNodeId));
        if (tmp.length) {
            cacheNode.typeDefinition = tmp[0].nodeId;
        }
        async.parallel({
            task1_read_browseName: (callback) => {
                if (cacheNode.browseName !== private_1.pendingBrowseName) {
                    return callback();
                }
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.BrowseName, (err, browseName) => {
                    cacheNode.browseName = browseName;
                    callback();
                });
            },
            task2_read_displayName: (callback) => {
                if (cacheNode.displayName) {
                    return callback();
                }
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.DisplayName, (err, value) => {
                    if (err) {
                        return callback(err);
                    }
                    cacheNode.displayName = value;
                    callback();
                });
            },
            task3_read_description: (callback) => {
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.Description, (err, value) => {
                    if (err) {
                        // description may not be defined and this is OK !
                        return callback();
                    }
                    cacheNode.description = (0, node_opcua_data_model_1.coerceLocalizedText)(value);
                    callback();
                });
            },
            task4_variable_dataType: (callback) => {
                // only if nodeClass is Variable || VariableType
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable && cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.VariableType) {
                    return callback();
                }
                const cache = cacheNode;
                // read dataType and DataType if node is a variable
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.DataType, (err, dataType) => {
                    if (!(dataType instanceof node_opcua_nodeid_1.NodeId)) {
                        return callback();
                    }
                    cache.dataType = dataType;
                    callback();
                });
            },
            task5_variable_dataValue: (callback) => {
                // only if nodeClass is Variable || VariableType
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable && cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.VariableType) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.Value, (err, value) => {
                    if (!err) {
                        (0, node_opcua_assert_1.assert)(value instanceof node_opcua_data_value_1.DataValue);
                        cache.dataValue = value;
                    }
                    callback();
                });
            },
            task6a_variable_arrayDimension: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable && cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.VariableType) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.ArrayDimensions, (err, value) => {
                    if (!err) {
                        const standardArray = convertToStandardArray(value);
                        cache.arrayDimensions = standardArray;
                        // xxx console.log("arrayDimensions  XXXX ", cache.arrayDimensions);
                    }
                    else {
                        cache.arrayDimensions = undefined; // set explicitly
                    }
                    callback();
                });
            },
            task6b_variable_valueRank: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable && cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.VariableType) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.ValueRank, (err, value) => {
                    if (!err) {
                        cache.valueRank = value;
                    }
                    callback();
                });
            },
            task7_variable_minimumSamplingInterval: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.MinimumSamplingInterval, (err, value) => {
                    cache.minimumSamplingInterval = value;
                    callback();
                });
            },
            task8_variable_accessLevel: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.AccessLevel, (err, value) => {
                    if (err) {
                        return callback(err);
                    }
                    cache.accessLevel = value;
                    callback();
                });
            },
            task9_variable_userAccessLevel: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.Variable) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.UserAccessLevel, (err, value) => {
                    if (err) {
                        return callback(err);
                    }
                    cache.userAccessLevel = value;
                    callback();
                });
            },
            taskA_referenceType_inverseName: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.ReferenceType) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.InverseName, (err, value) => {
                    if (err) {
                        return callback(err);
                    }
                    cache.inverseName = value;
                    callback();
                });
            },
            taskB_isAbstract: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.ReferenceType) {
                    return callback();
                }
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.IsAbstract, (err, value) => {
                    if (err) {
                        return callback(err);
                    }
                    cache.isAbstract = value;
                    callback();
                });
            },
            taskC_dataTypeDefinition: (callback) => {
                if (cacheNode.nodeClass !== node_opcua_data_model_1.NodeClass.DataType) {
                    return callback();
                }
                // dataTypeDefinition is new in 1.04
                const cache = cacheNode;
                this._defer_readNode(cacheNode.nodeId, node_opcua_data_model_1.AttributeIds.DataTypeDefinition, (err, value) => {
                    if (err) {
                        // may be we are crawling a 1.03 server => DataTypeDefinition was not defined yet
                        return callback();
                    }
                    cache.dataTypeDefinition = value;
                    callback();
                });
            }
        }, () => {
            _objectToBrowse.action(cacheNode);
        });
    }
    _process_browse_response_task(task, callback) {
        const objectsToBrowse = task.param.objectsToBrowse;
        const browseResults = task.param.browseResults;
        for (const pair of (0, underscore_1.zip)(objectsToBrowse, browseResults)) {
            const objectToBrowse = pair[0];
            const browseResult = pair[1];
            (0, node_opcua_assert_1.assert)(browseResult instanceof node_opcua_service_browse_1.BrowseResult);
            this._process_single_browseResult(objectToBrowse, browseResult);
        }
        setImmediate(callback);
    }
}
exports.NodeCrawlerBase = NodeCrawlerBase;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
NodeCrawlerBase.prototype.crawl = thenify.withCallback(NodeCrawlerBase.prototype.crawl);
//# sourceMappingURL=node_crawler_base.js.map