"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._readTime = exports._findBlockAtIndex = exports._readDirectoryName = exports.compactDirectoryName = exports._readValue = exports._readVersionValue = exports._readBooleanValue = exports._readIntegerValue = exports._readLongIntegerValue = exports._readSignatureValue = exports._readSignatureValueBin = exports._readECCAlgorithmIdentifier = exports._readAlgorithmIdentifier = exports._readObjectIdentifier = exports._readListOfInteger = exports._readIntegerAsByteString = exports._getBlock = exports._readOctetString = exports.formatBuffer2DigitHexWithColum = exports._readBitString = exports.parseBitString = exports._readStruct = exports.readTag = exports.TagType = void 0;
const assert = require("assert");
const oid_map_1 = require("./oid_map");
// https://github.com/lapo-luchini/asn1js/blob/master/asn1.js
var TagType;
(function (TagType) {
    TagType[TagType["BOOLEAN"] = 1] = "BOOLEAN";
    TagType[TagType["INTEGER"] = 2] = "INTEGER";
    TagType[TagType["BIT_STRING"] = 3] = "BIT_STRING";
    TagType[TagType["OCTET_STRING"] = 4] = "OCTET_STRING";
    TagType[TagType["NULL"] = 5] = "NULL";
    TagType[TagType["OBJECT_IDENTIFIER"] = 6] = "OBJECT_IDENTIFIER";
    TagType[TagType["UTF8String"] = 12] = "UTF8String";
    TagType[TagType["NumericString"] = 18] = "NumericString";
    TagType[TagType["PrintableString"] = 19] = "PrintableString";
    TagType[TagType["TeletexString"] = 20] = "TeletexString";
    TagType[TagType["IA5String"] = 22] = "IA5String";
    TagType[TagType["UTCTime"] = 23] = "UTCTime";
    TagType[TagType["GeneralizedTime"] = 24] = "GeneralizedTime";
    TagType[TagType["GraphicString"] = 25] = "GraphicString";
    TagType[TagType["VisibleString"] = 26] = "VisibleString";
    TagType[TagType["GeneralString"] = 27] = "GeneralString";
    TagType[TagType["UniversalString"] = 28] = "UniversalString";
    TagType[TagType["BMPString"] = 30] = "BMPString";
    TagType[TagType["SEQUENCE"] = 48] = "SEQUENCE";
    TagType[TagType["SET"] = 49] = "SET";
    TagType[TagType["A3"] = 163] = "A3";
})(TagType = exports.TagType || (exports.TagType = {}));
function readTag(buf, pos) {
    assert(buf instanceof Buffer);
    assert(Number.isFinite(pos) && pos >= 0);
    // istanbul ignore next
    if (buf.length <= pos) {
        throw new Error("Invalid position : buf.length=" + buf.length + " pos =" + pos);
    }
    const tag = buf.readUInt8(pos);
    pos += 1;
    let length = buf.readUInt8(pos);
    pos += 1;
    // tslint:disable:no-bitwise
    if (length > 127) {
        const nbBytes = length & 0x7f;
        length = 0;
        for (let i = 0; i < nbBytes; i++) {
            length = length * 256 + buf.readUInt8(pos);
            pos += 1;
        }
    }
    return { tag, position: pos, length };
}
exports.readTag = readTag;
function _readStruct(buf, blockInfo) {
    const length = blockInfo.length;
    let cursor = blockInfo.position;
    const end = blockInfo.position + length;
    const blocks = [];
    while (cursor < end) {
        const inner = readTag(buf, cursor);
        cursor = inner.position + inner.length;
        blocks.push(inner);
    }
    return blocks;
}
exports._readStruct = _readStruct;
function parseBitString(buffer, start, end, maxLength) {
    const unusedBit = buffer.readUInt8(start), lenBit = ((end - start - 1) << 3) - unusedBit, intro = "(" + lenBit + " bit)\n";
    let s = "", skip = unusedBit;
    for (let i = end - 1; i > start; --i) {
        const b = buffer.readUInt8(i);
        for (let j = skip; j < 8; ++j) {
            // noinspection JSBitwiseOperatorUsage
            s += (b >> j) & 1 ? "1" : "0";
        }
        skip = 0;
        assert(s.length <= maxLength);
    }
    return intro + s;
}
exports.parseBitString = parseBitString;
function _readBitString(buffer, block) {
    assert(block.tag === TagType.BIT_STRING);
    const data = _getBlock(buffer, block);
    // number of skipped bits
    const ignore_bits = data.readUInt8(0);
    return {
        lengthInBits: data.length * 8 - ignore_bits,
        lengthInBytes: data.length - 1,
        data: data.slice(1),
        debug: parseBitString(buffer, block.position, block.length + block.position, 5000),
    };
}
exports._readBitString = _readBitString;
function formatBuffer2DigitHexWithColum(buffer) {
    const value = [];
    for (let i = 0; i < buffer.length; i++) {
        value.push(("00" + buffer.readUInt8(i).toString(16)).substr(-2, 2));
    }
    // remove leading 00
    return value
        .join(":")
        .toUpperCase()
        .replace(/^(00:)*/, "");
}
exports.formatBuffer2DigitHexWithColum = formatBuffer2DigitHexWithColum;
function _readOctetString(buffer, block) {
    assert(block.tag === TagType.OCTET_STRING);
    const tag = readTag(buffer, block.position);
    assert(tag.tag === TagType.OCTET_STRING);
    const nbBytes = tag.length;
    const pos = tag.position;
    const b = buffer.slice(pos, pos + nbBytes);
    return b;
}
exports._readOctetString = _readOctetString;
function _getBlock(buffer, block) {
    const start = block.position;
    const end = block.position + block.length;
    return buffer.slice(start, end);
}
exports._getBlock = _getBlock;
function _readIntegerAsByteString(buffer, block) {
    return _getBlock(buffer, block);
}
exports._readIntegerAsByteString = _readIntegerAsByteString;
function _readListOfInteger(buffer) {
    const block = readTag(buffer, 0);
    const inner_blocks = _readStruct(buffer, block);
    return inner_blocks.map((bblock) => {
        return _readIntegerAsByteString(buffer, bblock);
    });
}
exports._readListOfInteger = _readListOfInteger;
function parseOID(buffer, start, end) {
    // ASN.1 JavaScript decoder
    // Copyright (c) 2008-2014 Lapo Luchini <lapo@lapo.it>
    let s = "", n = 0, bits = 0;
    for (let i = start; i < end; ++i) {
        const v = buffer.readUInt8(i);
        // tslint:disable-next-line: no-bitwise
        n = n * 128 + (v & 0x7f);
        bits += 7;
        // noinspection JSBitwiseOperatorUsage
        // tslint:disable-next-line: no-bitwise
        if (!(v & 0x80)) {
            // finished
            if (s === "") {
                const m = n < 80 ? (n < 40 ? 0 : 1) : 2;
                s = m + "." + (n - m * 40);
            }
            else {
                s += "." + n.toString();
            }
            n = 0;
            bits = 0;
        }
    }
    assert(bits === 0); // if (bits > 0) { s += ".incomplete"; }
    return s;
}
function _readObjectIdentifier(buffer, block) {
    assert(block.tag === TagType.OBJECT_IDENTIFIER);
    const b = buffer.slice(block.position, block.position + block.length);
    const oid = parseOID(b, 0, block.length);
    return {
        oid,
        name: oid_map_1.oid_map[oid] ? oid_map_1.oid_map[oid].d : oid,
    };
}
exports._readObjectIdentifier = _readObjectIdentifier;
function _readAlgorithmIdentifier(buffer, block) {
    const inner_blocks = _readStruct(buffer, block);
    return {
        identifier: _readObjectIdentifier(buffer, inner_blocks[0]).name,
    };
}
exports._readAlgorithmIdentifier = _readAlgorithmIdentifier;
;
function _readECCAlgorithmIdentifier(buffer, block) {
    const inner_blocks = _readStruct(buffer, block);
    return {
        identifier: _readObjectIdentifier(buffer, inner_blocks[1]).name, // difference with RSA as algorithm is second element of nested block
    };
}
exports._readECCAlgorithmIdentifier = _readECCAlgorithmIdentifier;
;
function _readSignatureValueBin(buffer, block) {
    return _readBitString(buffer, block).data;
}
exports._readSignatureValueBin = _readSignatureValueBin;
function _readSignatureValue(buffer, block) {
    return _readSignatureValueBin(buffer, block).toString("hex");
}
exports._readSignatureValue = _readSignatureValue;
function _readLongIntegerValue(buffer, block) {
    assert(block.tag === TagType.INTEGER, "expecting a INTEGER tag");
    const pos = block.position;
    const nbBytes = block.length;
    const buf = buffer.slice(pos, pos + nbBytes);
    return buf;
}
exports._readLongIntegerValue = _readLongIntegerValue;
function _readIntegerValue(buffer, block) {
    assert(block.tag === TagType.INTEGER, "expecting a INTEGER tag");
    let pos = block.position;
    const nbBytes = block.length;
    assert(nbBytes < 4);
    let value = 0;
    for (let i = 0; i < nbBytes; i++) {
        value = value * 256 + buffer.readUInt8(pos);
        pos += 1;
    }
    return value;
}
exports._readIntegerValue = _readIntegerValue;
function _readBooleanValue(buffer, block) {
    assert(block.tag === TagType.BOOLEAN, "expecting a BOOLEAN tag. got " + TagType[block.tag]);
    const pos = block.position;
    const nbBytes = block.length;
    assert(nbBytes < 4);
    const value = buffer.readUInt8(pos) ? true : false;
    return value;
}
exports._readBooleanValue = _readBooleanValue;
function _readVersionValue(buffer, block) {
    block = readTag(buffer, block.position);
    return _readIntegerValue(buffer, block);
}
exports._readVersionValue = _readVersionValue;
/*
 4.1.2.5.2  GeneralizedTime

 The generalized time type, GeneralizedTime, is a standard ASN.1 type
 for variable precision representation of time.  Optionally, the
 GeneralizedTime field can include a representation of the time
 differential between local and Greenwich Mean Time.

 For the purposes of this profile, GeneralizedTime values MUST be
 expressed Greenwich Mean Time (Zulu) and MUST include seconds (i.e.,
 times are YYYYMMDDHHMMSSZ), even where the number of seconds is zero.
 GeneralizedTime values MUST NOT include fractional seconds.

 */
function convertGeneralizedTime(str) {
    const year = parseInt(str.substr(0, 4), 10);
    const month = parseInt(str.substr(4, 2), 10) - 1;
    const day = parseInt(str.substr(6, 2), 10);
    const hours = parseInt(str.substr(8, 2), 10);
    const mins = parseInt(str.substr(10, 2), 10);
    const secs = parseInt(str.substr(12, 2), 10);
    return new Date(Date.UTC(year, month, day, hours, mins, secs));
}
function _readBMPString(buffer, block) {
    const strBuff = _getBlock(buffer, block);
    let str = "";
    for (let i = 0; i < strBuff.length; i += 2) {
        const word = strBuff.readUInt16BE(i);
        str += String.fromCharCode(word);
    }
    return str;
}
/*
 http://tools.ietf.org/html/rfc5280

 4.1.2.5. Validity
 [...]
 As conforming to this profile MUST always encode certificate
 validity dates through the year 2049 as UTCTime; certificate validity
 dates in 2050 or later MUST be encoded as GeneralizedTime.
 Conforming applications MUST be able to process validity dates that
 are encoded in either UTCTime or GeneralizedTime.
 [...]

 4.1.2.5.1  UTCTime

 The universal time type, UTCTime, is a standard ASN.1 type intended
 for representation of dates and time.  UTCTime specifies the year
 through the two low order digits and time is specified to the
 precision of one minute or one second.  UTCTime includes either Z
 (for Zulu, or Greenwich Mean Time) or a time differential.

 For the purposes of this profile, UTCTime values MUST be expressed
 Greenwich Mean Time (Zulu) and MUST include seconds (i.e., times are
 YYMMDDHHMMSSZ), even where the number of seconds is zero.  Conforming
 systems MUST interpret the year field (YY) as follows:

 Where YY is greater than or equal to 50, the year SHALL be
 interpreted as 19YY; and

 Where YY is less than 50, the year SHALL be interpreted as 20YY.
 */
function convertUTCTime(str) {
    let year = parseInt(str.substr(0, 2), 10);
    const month = parseInt(str.substr(2, 2), 10) - 1;
    const day = parseInt(str.substr(4, 2), 10);
    const hours = parseInt(str.substr(6, 2), 10);
    const mins = parseInt(str.substr(8, 2), 10);
    const secs = parseInt(str.substr(10, 2), 10);
    year += year >= 50 ? 1900 : 2000;
    return new Date(Date.UTC(year, month, day, hours, mins, secs));
}
function _readValue(buffer, block) {
    switch (block.tag) {
        case TagType.BOOLEAN:
            return _readBooleanValue(buffer, block);
        case TagType.BMPString:
            return _readBMPString(buffer, block);
        case TagType.PrintableString:
        case TagType.TeletexString:
        case TagType.UTF8String:
        case TagType.NumericString:
        case TagType.IA5String:
            return _getBlock(buffer, block).toString("ascii");
        case TagType.UTCTime:
            return convertUTCTime(_getBlock(buffer, block).toString("ascii"));
        case TagType.GeneralizedTime:
            return convertGeneralizedTime(_getBlock(buffer, block).toString("ascii"));
        default:
            throw new Error("Invalid tag 0x" + block.tag.toString(16) + "");
        //xx return " ??? <" + block.tag + ">";
    }
}
exports._readValue = _readValue;
function compactDirectoryName(d) {
    return JSON.stringify(d);
}
exports.compactDirectoryName = compactDirectoryName;
function _readDirectoryName(buffer, block) {
    // AttributeTypeAndValue ::= SEQUENCE {
    //    type   ATTRIBUTE.&id({SupportedAttributes}),
    //    value  ATTRIBUTE.&Type({SupportedAttributes}{@type}),
    const set_blocks = _readStruct(buffer, block);
    const names = {};
    for (const set_block of set_blocks) {
        assert(set_block.tag === 0x31);
        const blocks = _readStruct(buffer, set_block);
        assert(blocks.length === 1);
        assert(blocks[0].tag === 0x30);
        const sequenceBlock = _readStruct(buffer, blocks[0]);
        assert(sequenceBlock.length === 2);
        const type = _readObjectIdentifier(buffer, sequenceBlock[0]);
        names[type.name] = _readValue(buffer, sequenceBlock[1]);
    }
    return names;
}
exports._readDirectoryName = _readDirectoryName;
function _findBlockAtIndex(blocks, index) {
    const tmp = blocks.filter((b) => b.tag === 0xa0 + index || b.tag === 0x80 + index);
    if (tmp.length === 0) {
        return null;
    }
    return tmp[0];
}
exports._findBlockAtIndex = _findBlockAtIndex;
function _readTime(buffer, block) {
    return _readValue(buffer, block);
}
exports._readTime = _readTime;
//# sourceMappingURL=asn1.js.map