/// <reference types="node" />
/**
 * @module node-opcua-server
 */
import { EventEmitter } from "events";
import { AddressSpace, ISessionContext, ContinuationData } from "node-opcua-address-space";
import { DataValue } from "node-opcua-data-value";
import { ServerDiagnosticsSummaryDataType, ServerState, ServerStatusDataType } from "node-opcua-common";
import { AttributeIds, LocalizedTextLike } from "node-opcua-data-model";
import { NodeId, NodeIdLike } from "node-opcua-nodeid";
import { BrowseResult } from "node-opcua-service-browse";
import { ReadRequest, TimestampsToReturn } from "node-opcua-service-read";
import { CreateSubscriptionRequestLike } from "node-opcua-client";
import { ObjectRegistry } from "node-opcua-object-registry";
import { TransferResult } from "node-opcua-service-subscription";
import { ApplicationDescription } from "node-opcua-service-endpoints";
import { HistoryReadRequest, HistoryReadResult, HistoryReadValueId } from "node-opcua-service-history";
import { StatusCode } from "node-opcua-status-code";
import { BrowseDescription, BrowsePath, BrowsePathResult, BuildInfo, BuildInfoOptions, ReadAtTimeDetails, ReadEventDetails, ReadProcessedDetails, ReadRawModifiedDetails, WriteValue, ReadValueId } from "node-opcua-types";
import { HistoryServerCapabilities, HistoryServerCapabilitiesOptions } from "./history_server_capabilities";
import { ServerCapabilities, ServerCapabilitiesOptions } from "./server_capabilities";
import { ServerSession } from "./server_session";
import { Subscription } from "./server_subscription";
import { OPCUAServerOptions } from "./opcua_server";
export declare type StringGetter = () => string;
export interface ServerEngineOptions {
    applicationUri: string | StringGetter;
    buildInfo?: BuildInfoOptions;
    isAuditing?: boolean;
    /**
     * set to true to enable serverDiagnostics
     */
    serverDiagnosticsEnabled?: boolean;
    serverCapabilities?: ServerCapabilitiesOptions;
    historyServerCapabilities?: HistoryServerCapabilitiesOptions;
}
export interface CreateSessionOption {
    clientDescription?: ApplicationDescription;
    sessionTimeout?: number;
}
export declare type ClosingReason = "Timeout" | "Terminated" | "CloseSession" | "Forcing";
export declare type ShutdownTask = (this: ServerEngine) => void | Promise<void>;
/**
 *
 */
export declare class ServerEngine extends EventEmitter {
    static readonly registry: ObjectRegistry;
    isAuditing: boolean;
    serverDiagnosticsSummary: ServerDiagnosticsSummaryDataType;
    serverDiagnosticsEnabled: boolean;
    serverCapabilities: ServerCapabilities;
    historyServerCapabilities: HistoryServerCapabilities;
    clientDescription?: ApplicationDescription;
    addressSpace: AddressSpace | null;
    _internalState: "creating" | "initializing" | "initialized" | "shutdown" | "disposed";
    private _sessions;
    private _closedSessions;
    private _orphanPublishEngine?;
    private _shutdownTasks;
    private _applicationUri;
    private _expectedShutdownTime;
    private _serverStatus;
    private _globalCounter;
    constructor(options: ServerEngineOptions);
    isStarted(): boolean;
    dispose(): void;
    get startTime(): Date;
    get currentTime(): Date;
    get buildInfo(): BuildInfo;
    /**
     * register a function that will be called when the server will perform its shut down.
     * @method registerShutdownTask
     */
    registerShutdownTask(task: (this: ServerEngine) => void): void;
    /**
     * @method shutdown
     */
    shutdown(): Promise<void>;
    /**
     * the number of active sessions
     */
    get currentSessionCount(): number;
    /**
     * the cumulated number of sessions that have been opened since this object exists
     */
    get cumulatedSessionCount(): number;
    /**
     * the number of active subscriptions.
     */
    get currentSubscriptionCount(): number;
    /**
     * the cumulated number of subscriptions that have been created since this object exists
     */
    get cumulatedSubscriptionCount(): number;
    get rejectedSessionCount(): number;
    get rejectedRequestsCount(): number;
    get sessionAbortCount(): number;
    get sessionTimeoutCount(): number;
    get publishingIntervalCount(): number;
    incrementSessionTimeoutCount(): void;
    incrementSessionAbortCount(): void;
    incrementRejectedRequestsCount(): void;
    /**
     * increment rejected session count (also increment rejected requests count)
     */
    incrementRejectedSessionCount(): void;
    incrementSecurityRejectedRequestsCount(): void;
    /**
     * increment rejected session count (also increment rejected requests count)
     */
    incrementSecurityRejectedSessionCount(): void;
    setShutdownTime(date: Date): void;
    setShutdownReason(reason: LocalizedTextLike): void;
    /**
     * @method secondsTillShutdown
     * @return the approximate number of seconds until the server will be shut down. The
     * value is only relevant once the state changes into SHUTDOWN.
     */
    secondsTillShutdown(): number;
    /**
     * the name of the server
     */
    get serverName(): string;
    /**
     * the server urn
     */
    get serverNameUrn(): string;
    /**
     * the urn of the server namespace
     */
    get serverNamespaceUrn(): string;
    get serverStatus(): ServerStatusDataType;
    setServerState(serverState: ServerState): void;
    getServerDiagnosticsEnabledFlag(): boolean;
    /**
     * @method initialize
     * @async
     *
     * @param options {Object}
     * @param options.nodeset_filename {String} - [option](default : 'mini.Node.Set2.xml' )
     * @param callback
     */
    initialize(options: OPCUAServerOptions, callback: () => void): void;
    /**
     *
     * @method browseSingleNode
     * @param nodeId {NodeId|String} : the nodeid of the element to browse
     * @param browseDescription
     * @param browseDescription.browseDirection {BrowseDirection} :
     * @param browseDescription.referenceTypeId {String|NodeId}
     * @param [context]
     * @return  the browse result
     */
    browseSingleNode(nodeId: NodeIdLike, browseDescription: BrowseDescription, context?: ISessionContext): BrowseResult;
    browseWithAutomaticExpansion(nodesToBrowse: BrowseDescription[], context?: ISessionContext): Promise<BrowseResult[]>;
    /**
     *
     */
    browse(nodesToBrowse: BrowseDescription[], context?: ISessionContext): BrowseResult[];
    /**
     *
     * @method readSingleNode
     * @param context
     * @param nodeId
     * @param attributeId
     * @param [timestampsToReturn=TimestampsToReturn.Neither]
     * @return DataValue
     */
    readSingleNode(context: ISessionContext, nodeId: NodeId | string, attributeId: AttributeIds, timestampsToReturn?: TimestampsToReturn): DataValue;
    /**
     *
     *
     *    Maximum age of the value to be read in milliseconds. The age of the value is based on the difference between
     *    the ServerTimestamp and the time when the  Server starts processing the request. For example if the Client
     *    specifies a maxAge of 500 milliseconds and it takes 100 milliseconds until the Server starts  processing
     *    the request, the age of the returned value could be 600 milliseconds  prior to the time it was requested.
     *    If the Server has one or more values of an Attribute that are within the maximum age, it can return any one
     *    of the values or it can read a new value from the data  source. The number of values of an Attribute that
     *    a Server has depends on the  number of MonitoredItems that are defined for the Attribute. In any case,
     *    the Client can make no assumption about which copy of the data will be returned.
     *    If the Server does not have a value that is within the maximum age, it shall attempt to read a new value
     *    from the data source.
     *    If the Server cannot meet the requested maxAge, it returns its 'best effort' value rather than rejecting the
     *    request.
     *    This may occur when the time it takes the Server to process and return the new data value after it has been
     *    accessed is greater than the specified maximum age.
     *    If maxAge is set to 0, the Server shall attempt to read a new value from the data source.
     *    If maxAge is set to the max Int32 value or greater, the Server shall attempt to get a cached value.
     *    Negative values are invalid for maxAge.
     *
     *  @return  an array of DataValue
     */
    read(context: ISessionContext, readRequest: ReadRequest): DataValue[];
    /**
     *
     * @method writeSingleNode
     * @param context
     * @param writeValue
     * @param callback
     * @param callback.err
     * @param callback.statusCode
     * @async
     */
    writeSingleNode(context: ISessionContext, writeValue: WriteValue, callback: (err: Error | null, statusCode?: StatusCode) => void): void;
    /**
     * write a collection of nodes
     * @method write
     * @param context
     * @param nodesToWrite
     * @param callback
     * @param callback.err
     * @param callback.results
     * @async
     */
    write(context: ISessionContext, nodesToWrite: WriteValue[], callback: (err: Error | null, statusCodes?: StatusCode[]) => void): void;
    /**
     *
     */
    historyReadSingleNode(context: ISessionContext, nodeId: NodeId, attributeId: AttributeIds, historyReadDetails: ReadRawModifiedDetails | ReadEventDetails | ReadProcessedDetails | ReadAtTimeDetails, timestampsToReturn: TimestampsToReturn, continuationData: ContinuationData, callback: (err: Error | null, results?: HistoryReadResult) => void): void;
    /**
     *
     *  @method historyRead
     *  @param context {SessionContext}
     *  @param historyReadRequest {HistoryReadRequest}
     *  @param historyReadRequest.requestHeader  {RequestHeader}
     *  @param historyReadRequest.historyReadDetails  {HistoryReadDetails}
     *  @param historyReadRequest.timestampsToReturn  {TimestampsToReturn}
     *  @param historyReadRequest.releaseContinuationPoints  {Boolean}
     *  @param historyReadRequest.nodesToRead {HistoryReadValueId[]}
     *  @param callback
     *  @param callback.err
     *  @param callback.results {HistoryReadResult[]}
     */
    historyRead(context: ISessionContext, historyReadRequest: HistoryReadRequest, callback: (err: Error | null, results: HistoryReadResult[]) => void): void;
    getOldestInactiveSession(): ServerSession | null;
    /**
     * create a new server session object.
     * @class ServerEngine
     * @method createSession
     * @param  [options] {Object}
     * @param  [options.sessionTimeout = 1000] {Number} sessionTimeout
     * @param  [options.clientDescription] {ApplicationDescription}
     * @return {ServerSession}
     */
    createSession(options: CreateSessionOption): ServerSession;
    /**
     * @method closeSession
     * @param authenticationToken
     * @param deleteSubscriptions {Boolean} : true if session's subscription shall be deleted
     * @param {String} [reason = "CloseSession"] the reason for closing the session (
     *                 shall be "Timeout", "Terminated" or "CloseSession")
     *
     *
     * what the specs say:
     * -------------------
     *
     * If a Client invokes the CloseSession Service then all Subscriptions associated with the Session are also deleted
     * if the deleteSubscriptions flag is set to TRUE. If a Server terminates a Session for any other reason,
     * Subscriptions associated with the Session, are not deleted. Each Subscription has its own lifetime to protect
     * against data loss in the case of a Session termination. In these cases, the Subscription can be reassigned to
     * another Client before its lifetime expires.
     */
    closeSession(authenticationToken: NodeId, deleteSubscriptions: boolean, reason: ClosingReason): void;
    findSubscription(subscriptionId: number): Subscription | null;
    findOrphanSubscription(subscriptionId: number): Subscription | null;
    deleteOrphanSubscription(subscription: Subscription): StatusCode;
    /**
     * @method transferSubscription
     * @param session           {ServerSession}  - the new session that will own the subscription
     * @param subscriptionId    {IntegerId}      - the subscription Id to transfer
     * @param sendInitialValues {Boolean}        - true if initial values will be resent.
     * @return                  {TransferResult}
     */
    transferSubscription(session: ServerSession, subscriptionId: number, sendInitialValues: boolean): Promise<TransferResult>;
    /**
     * retrieve a session by its authenticationToken.
     *
     * @method getSession
     * @param authenticationToken
     * @param activeOnly
     * @return {ServerSession}
     */
    getSession(authenticationToken: NodeId, activeOnly?: boolean): ServerSession | null;
    /**
     */
    browsePath(browsePath: BrowsePath): BrowsePathResult;
    /**
     *
     * performs a call to ```asyncRefresh``` on all variable nodes that provide an async refresh func.
     *
     * @method refreshValues
     * @param nodesToRefresh {Array<Object>}  an array containing the node to consider
     * Each element of the array shall be of the form { nodeId: <xxx>, attributeIds: <value> }.
     * @param callback
     * @param callback.err
     * @param callback.data  an array containing value read
     * The array length matches the number of  nodeIds that are candidate for an async refresh (i.e: nodes that
     * are of type Variable with asyncRefresh func }
     *
     * @async
     */
    refreshValues(nodesToRefresh: ReadValueId[] | HistoryReadValueId[], maxAge: number, callback: (err: Error | null, dataValues?: DataValue[]) => void): void;
    private _exposeSubscriptionDiagnostics;
    protected _unexposeSubscriptionDiagnostics(subscription: Subscription): void;
    /**
     * create a new subscription
     * @return {Subscription}
     */
    _createSubscriptionOnSession(session: ServerSession, request: CreateSubscriptionRequestLike): Subscription;
    private __findNode;
    private _readSingleNode;
    private _historyReadSingleNode;
    /**
     */
    private __internal_bindMethod;
    private _getServerSubscriptionDiagnosticsArrayNode;
}
